### 9. Shell基础

> Shell的两种主要语法类型有Bourne和C，这两种语法彼此不兼容。
>
> 1. Bourne家族主要包括sh、ksh、**Bash**、psh、zsh；
> 2. C家族主要包括：csh、tcsh

#### linux支持的shells

```shell
cat /etc/shells		#输入shell的标识名可以互相切换(单用户，系统修复模式启动的shell就是sh)
sh			#进入sh shell中
exit		#退出
```

#### shell脚本的执行方式

```shell
#echo 后加！需要单引号
echo "hello world"
echo 'hello world!!!'

#-e 支持\为转义符
echo -e "ab\bc"	
echo -e "\e[1;31m abcd \e[0m" #\e[1;开启颜色输出，\e[0m结束颜色输出

```

第一个脚本

```shell
vim hello.sh
#!/bin/Bash		#标识当前写的程序是shell脚本，并不是注释
#The first program
# Author: shenchao （E-mail: shenchao@lampbrother.net）

echo -e "Mr. Shen Chao is the most honest man in LampBrother"
```

```shell
chmod 755 hello.sh
./hello.sh		#可以用相对路径或绝对路径来执行
bash hello.sh	#调用bash执行，不用执行权限
```

注意，windows下换行符`^M$` CRLF和linux换行符`$`LF不同，可以通过dos2unix来转换。

#### BASH的基本功能

```shell
history
#~/.bash.history中记录的为前一次登录以前的命令，这一次登录的命令被暂存在内存中。
#历史命令默认保存1000行，可在/etc/profile中修改 HISTSIZE
history -c	#清空历史命令
history -w	#强制将缓存中的历史命令写入~/.bash.history
#使用上、下箭头调用以前的历史命令
#使用“!n”重复执行第n条历史命令
#使用“!!”重复执行上一条命令
#使用“!字串”重复执行最后一条以该字串开头的命令

```

```shell
#Tab	命令、文件补全
```

```shell
alias	#查询命令别名
alias lm='ls -al'	#临时生效
vi /root/.bashrc	#永久生效
unalias 别名
```

##### 命令执行顺序

1. 第一顺位执行用绝对路径或相对路径执行的命令。
2. 第二顺位执行别名。
3. 第三顺位执行Bash的内部命令。
4. 第四顺位执行按照$PATH环境变量定义的目录查找顺序找到的第一个命令

##### Bash常用快捷键

| 快捷键 | 作用                                                         |
| ------ | ------------------------------------------------------------ |
| CRTL+C | 强制终止当前的命令。                                         |
| CRTL+L | 清屏，相当于clear命令。                                      |
| CRTL+U | 删除或剪切光标之前的命令。我输入了一行很长的命令，不用使用退格键一个一个字符的删除，使用这个快捷键会更加方便 |
| CRTL+Y | 粘贴ctrl+U或ctrl+K剪切的内容。                               |
| CRTL+R | 在历史命令中搜索，按下ctrl+R之后，就会出现搜索界面，只要输入搜索内容，就会从历史命令中搜索。 |
| CRTL+D | 退出当前终端。                                               |
| CRTL+Z | 暂停，并放入后台。这个快捷键牵扯工作管理的内容，我们在系统管理章节详细介绍。 |

##### 输入输出重定向

标准输入输出

| 设备   | 设备文件名  | 文件描述符 | 类型         |
| ------ | ----------- | ---------- | ------------ |
| 键盘   | /dev/stdin  | 0          | 标准输入     |
| 显示器 | /dev/sdtout | 1          | 标准输出     |
| 显示器 | /dev/sdterr | 2          | 标准错误输出 |

输出重定向

| 类 型                      | 符 号                | 作用                                                         |
| -------------------------- | -------------------- | ------------------------------------------------------------ |
| 标准输出重定向             | 命令 > 文件          | 以覆盖的方式，把命令的、正确输出输出到指定的文、件或设备当中。 |
|                            | 命令 >> 文件         | 以追加的方式，把命令的正确输出输出到指定的文件或设备当中。   |
| 标准错误输出重定向         | 错误命令 2>文件      | 以覆盖的方式，把命令的错误输出输出到指定的文件或设备当中。   |
|                            | 错误命令 2>>文件     | 以追加的方式，把命令的错误输出输出到指定的文件或设备当中。   |
| 正确输出和错误输出同时保存 | 命令 > 文件 2>&1     | 以覆盖的方式，把正确输出和错误输出都保存到同一个文件当中。   |
|                            | 命令 >> 文件 2>&1    | 以追加的方式，把正确输出和错误输出都保存到同一个文件当中。   |
|                            | 命令 &>文件          | 以覆盖的方式，把正确输出和错误输出都保存到同一个文件当中。   |
|                            | 命令 &>>文件         | 以追加的方式，把正确输出和错误输出都保存到同一个文件当中。   |
|                            | 命令>>文件1 2>>文件2 | 把正确的输出追加到文件1中，把错误的输出追加到文件2中。       |

输入重定向

```shell
wc
wc < 文件
wc << 标识符
```

##### 多命令顺序执行与管道符

| 多命令执行符 | 格式             | 作用                                                         |
| ------------ | ---------------- | ------------------------------------------------------------ |
| ;            | 命令1；命令2     | 多个命令顺序执行，命令之间没有任何逻辑联系                   |
| &&           | 命令1 && 命令2   | 逻辑与，当命令1正确执行，则命令2才会执行<br />当命令1执行不正确，则命令2不会执行 |
| \|\|         | 命令1 \|\| 命令2 | 逻辑或，当命令1 执行不正确，则命令2才会执行<br />当命令1正确执行，则命令2不会执行 |

```shell
dd if=输入文件 of=输出文件 bs=字节数 count=个数
date ; dd if=/dev/zero of=/root/testfile bs=1k count=100000 ;date
```

```shell
命令1 | 命令2	#命令1的正确输出作为命令2的操作对象
ll -a /etc/ | more
netstat -an | grep "ESTABLISHED"

```

```shell
grep [选项] "搜索内容" "文件内容"
-i： 忽略大小写
-n： 输出行号
-v： 反向查找
--color=auto 搜索出的关键字用颜色显示

```

##### 通配符与其他特殊符号

| 通配符 | 作 用                                                        |
| ------ | ------------------------------------------------------------ |
| ？     | 匹配一个任意字符                                             |
| *      | 匹配0个或任意多个任意字符，也就是可以匹配任何内容            |
| []     | 匹配中括号中任意一个字符。例如：[abc]代表一定匹配一个字符，或者是a，或者是b，或者是c。 |
| [-]    | 匹配中括号中任意一个字符，-代表一个范围。例如：[a-z]代表匹配一个小写字母。 |
| [^]    | 逻辑非，表示匹配不是中括号内的一个字符。例如：`[^0-9]`代表匹配一个不是数字的字符。 |

| 符 号 | 作 用                                                        |
| ----- | ------------------------------------------------------------ |
| ' '   | 单引号。在单引号中所有的特殊符号，如“$”和“`”(反引号)都没有特殊含义。 |
| " "   | 双引号。在双引号中特殊符号大多数没有特殊含义，但是“$”、“`”和“\”是例外，拥有“调用变量的值”、“引用命令”和“转义符”的特殊含义。 |
| ``    | 反引号。反引号括起来的内容是系统命令，在Bash中会先执行它。和$()作用一样，不过推荐使用$()，因为反引号非常容易看错。 |
| $()   | 和反引号作用一样，用来引用系统命令，但不会被看错。           |
| #     | 在Shell脚本中，#开头的行代表注释。                           |
| $     | 用于调用变量的值，如需要调用变量name的值时，需要用$name的方式得到变量的值。 |
| \     | 转义符，跟在\之后的特殊符号将失去特殊含义，变为普通字符。如\$将输出“$”符号，而不当做是变量引用。 |

#### Bash变量

1. 变量名称可以由字母、数字和下划线组成，但是不能以数字开头。如果变量名是“2name”则是错误的。
2. 在Bash中，**变量的默认类型都是字符串型**，如果要进行数值运算，则必修指定变量类型为数值型。变量用等号连接值，**等号左右两侧不能有空格**。
3. 变量的值如果有空格，需要使用单引号或双引号包括。
4. 在变量的值中，可以使用“\”转义符。
5. 如果需要增加变量的值，那么可以进行变量值的叠加。不过变量需要用双引号包含“$变量名”或用${变量名}包含。
6. 如果是把命令的结果作为变量值赋予变量，则需要使用反引号或$()包含命令。
7. 环境变量名建议大写，便于区分。

变量分类

1. 用户自定义变量。（只在当前shell生效）
2. 环境变量：这种变量中主要保存的是和系统操作环境相关的数据。（当前shell和子shell生效，写入配置文件后，所有shell都生效）
3. 位置参数变量：这种变量主要是用来向脚本当中传递参数或数据的，变量名不能自定义，变量作用是固定的。
4. 预定义变量：是Bash中已经定义好的变量，变量名不能自定义，变量作用也是固定的。

```shell
name="brother dong"	#变量定义-用户自定义变量
echo $name
name="$name"sssss	#变量叠加
name=${name}sssss
set			#变量查看
unset name	#变量删除

```

```shell
yum -y install psmisc 
pstree		#树型显示当前运行的进程。可以看到shell关系

set		#可以看到所有变量，但是我的set为啥嫩奇怪

export 变量名=变量值
#申明变量
env
#查询变量
unset 变量名
#删除变量

```

PATH：系统查找命令的路径

PS1：定义系统提示符的变量

| 符号 | 含义                                                         |
| ---- | ------------------------------------------------------------ |
| \d： | 显示日期，格式为“星期 月 日”                                 |
| \h： | 显示简写主机名。如默认主机名“localhost”                      |
| \t： | 显示24小时制时间，格式为“HH:MM:SS”                           |
| \T： | 显示12小时制时间，格式为“HH:MM:SS”                           |
| \A： | 显示24小时制时间，格式为“HH:MM”                              |
| \u： | 显示当前用户名                                               |
| \w： | 显示当前所在目录的完整名称                                   |
| \W： | 显示当前所在目录的最后一个目录                               |
| \#： | 执行的第几个命令                                             |
| \$： | 提示符。如果是root用户会显示提示符为“#”，如果是普通用户会显示提示符为“$” |

```shell
PS1='[\u@\t \w]\$ '		#临时生效

```

| 位置参数变量 | 作 用                                                        |
| ------------ | ------------------------------------------------------------ |
| $n           | n为数字，$0代表命令本身，$1-$9代表第一到第九个参数，十以上的参数需要用大括号包含，如${10}. |
| $*           | 这个变量代表命令行中所有的参数，$*把所有的参数看成一个整体   |
| $@           | 这个变量也代表命令行中所有的参数，不过$@把每个参数区分对待   |
| $#           | 这个变量代表命令行中所有参数的个数                           |

| 预定义变量 | 作 用                                                        |
| ---------- | ------------------------------------------------------------ |
| $？        | 最后一次执行的命令的返回状态。如果这个变<br/>量的值为0，证明上一个命令正确执行；如果<br/>这个变量的值为非0（具体是哪个数，由命令<br/>自己来决定），则证明上一个命令执行不正确<br/>了。 |
| $$         | 当前进程的进程号（PID）                                      |
| $!         | 后台运行的最后一个进程的进程号（PID）                        |

```shell
#!/bin/bash
# Author: shenchao （E-mail: shenchao@lampbrother.net）
echo "The current process is $$"
#输出当前进程的PID。
#这个PID就是variable.sh这个脚本执行时，生成的进程的PID
find /root -name hello.sh &
#使用find命令在root目录下查找hello.sh文件
#符号&的意思是把命令放入后台执行，工作管理我们在系统管理章节
会详细介绍
echo "The last one Daemon process is $!"

```

接收键盘输入

```shell
read [选项] [变量名]
-p “提示信息”：在等待read输入时，输出提示信息
-t 秒数： read命令会一直等待用户输入，使用
此选项可以指定等待时间
-n 字符数： read命令只接受指定的字符数，就会
执行
-s： 隐藏输入的数据，适用于机密信息的
输入

```



```shell
#!/bin/bash
# Author: shenchao （E-mail: shenchao@lampbrother.net）
read -t 30 -p "Please input your name: " name
#提示“请输入姓名”并等待30秒，把用户的输入保存入变量name中
echo "Name is $name "
read -s -t 30 -p "Please enter your age: " age
#年龄是隐私，所以我们用“-s”选项隐藏输入
echo -e "\n"
echo "Age is $age "
read -n 1 -t 30 -p "Please select your gender[M/F]: "gender
#使用“-n 1”选项只接收一个输入字符就会执行（都不用输入回车）
echo -e "\n"
echo "Sex is $gender"

```

#### Bash运算符

```shell
declare [+/-][选项] 变量名
-： 给变量设定类型属性
+： 取消变量的类型属性
-i： 将变量声明为整数型（integer）
-x： 将变量声明为环境变量
-p： 显示指定变量的被声明的类型

```

```shell
aa=1
bb=2
declare -i cc=$aa+$bb
dd=$(expr $aa + $bb)
#dd的值是aa和bb的和。注意“+”号左右两侧必须有空格
ff=$(( $aa+$bb ))
gg=$[ $aa+$bb ]

```

运算符

| 优先级 | 运算符                              | 说明                               |
| ------ | ----------------------------------- | ---------------------------------- |
| 13     | -, +                                | 单目负、单目正                     |
| 12     | !, ~                                | 逻辑非、按位取反或补码             |
| 11     | * , / , %                           | 乘、除、取模                       |
| 10     | +, -                                | 加、减                             |
| 9      | << , >>                             | 按位左移、按位右移                 |
| 8      | < =, > =, < , >                     | 小于或等于、大于或等于、小于、大于 |
| 7      | == , !=                             | 等于、不等于                       |
| 6      | &                                   | 按位与                             |
| 5      | ^                                   | 按位异或                           |
| 4      | \|                                  | 按位或                             |
| 3      | &&                                  | 逻辑与                             |
| 2      | \|\|                                | 逻辑或                             |
| 1      | =,+=,-=,*=,/=,%=,&=, ^=,=, <<=, >>= | 赋值、运算且赋值                   |

| 变量置换方式 | 变量y没有设置                      | 变量y为空值            | 变量y设置值  |
| ------------ | ---------------------------------- | ---------------------- | ------------ |
| x=${y-新值}  | x=新值                             | x为空                  | x=$y         |
| x=${y:-新值} | x=新值                             | x=新值                 | x=$y         |
| x=${y+新值}  | x为空                              | x=新值                 | x=新值       |
| x=${y:+新值} | x为空                              | x为空                  | x=新值       |
| x=${y=新值}  | x=新值 y=新值                      | x为空 y值不变          | x=$y y值不变 |
| x=${y:=新值} | x=新值 y=新值                      | x=新值 y=新值          | x=$y y值不变 |
| x=${y?新值}  | 新值输出到标准错误输出（就是屏幕） | x为空                  | x=$y         |
| x=${y:?新值} | 新值输出到标准错误输出             | 新值输出到标准错误输出 | x=$y         |

```shell
y=""	#双引号代表为空

```

#### 环境变量配置文件

```shell
source 配置文件
. 配置文件
#两者作用相同，都是让配置文件立即生效。


```

五个系统默认环境变量配置文件

```shell
/etc/profile
/etc/profile.d/*.sh	#这个是一组文件
~/.bash_profile
~/.bashrc
/etc/bashrc

```

![1565858244081](D:\Workspaces\Typora\image\I59.png)

1. /etc/profile的作用：
   - USER变量：
   - LOGNAME变量：
   - MAIL变量：
   - PATH变量：
   - HOSTNAME变量：
   - HISTSIZE变量：
   - umask：
   - 调用/etc/profile.d/*.sh文件
2. ~/.bash_profile的作用
   - 调用了~/.bashrc文件。
   - 在PATH变量后面加入了“:$HOME/bin”
     这个目录
3. ~/.bashrc的作用
   - 定义默认别名
   - 调用/etc/bashrc
4. /etc/bashrc的作用
   - PS1变量
   - umask
   - PATH变量
   - 调用/etc/profile.d/*.sh文件

```shell
~/.bash_logout	#注销时生效的环境变量配置文件
~/bash_history	#~/bash_history

```

**Shell登录信息** 

| 转义符 | 作 用                            |
| :----: | -------------------------------- |
|   \d   | 显示当前系统日期                 |
|   \s   | 显示操作系统名称                 |
|   \l   | 显示登录的终端号，这个比较常用。 |
|   \m   | 显示硬件体系结构，如i386、i686等 |
|   \n   | 显示主机名                       |
|   \o   | 显示域名                         |
|   \r   | 显示内核版本                     |
|   \t   | 显示当前系统时间                 |
|   \u   | 显示当前登录用户的序列号         |

1. 本地终端欢迎信息： /etc/issue

2. 远程终端欢迎信息： /etc/issue.net

   - 转义符在/etc/issue.net文件中不能使用

   - 是否显示此欢迎信息，由ssh的配置文件/etc/ssh/sshd_config决定，加入“Banner/etc/issue.net”行才能显示（记得重启SSH服务）

   - ```shell
     service sshd restart
     ```

3. 登陆后欢迎信息：/etc/motd

   - 不管是本地登录，还是远程登录，都可以显
     示此欢迎信息