### 10. Shell编程

---

#### 10.1 基础正则表达式

- **正则表达式**用来在文件中匹配符合条件的字符串，正则是**包含匹配**。grep、awk、sed等命令可以支持正则表达式。
- **通配符**用来匹配符合条件的文件名，通配符是**完全匹配**。ls、find、cp这些命令不支持正则表达式，所以只能使用shell自己的通配符来进行匹配了。`(*,?,[])`

基础正则表达式

|  元字符   | 作用                                                         |
| :-------: | ------------------------------------------------------------ |
|    `*`    | 前一个字符匹配0次或任意多次。                                |
|    `.`    | 匹配除了换行符外任意一个字符。                               |
|    `^`    | 匹配行首。例如：^hello会匹配以hello开头的行。                |
|    `$`    | 匹配行尾。例如：hello&会匹配以hello结尾的行。                |
|   `[]`    | 匹配中括号中指定的任意一个字符，只匹配一个字符。例如：`[aoeiu]` 匹配任意一个元音字母，[0-9] 匹配任意一位数字， `[a-z][0-9]`匹配小写字和一位数字构成的两位字符。 |
|   `[^]`   | 匹配除中括号的字符以外的任意一个字符。例如：`[^0-9]` 匹配任意一位非数字字符，`[^a-z]` 表示任意一位非小写字母。 |
|    `\`    | 转义符。用于取消讲特殊符号的含义取消。                       |
|  `\{n\}`  | 表示其前面的字符恰好出现n次。例如：`[0-9]\{4\} `匹配4位数字，`[1][3-8][0-9]\{9\} `匹配手机号码。 |
| `\{n,\}`  | 表示其前面的字符出现不小于n次。例如：` [0-9]\{2,\} `表示两位及以上的数字。 |
| `\{n,m\}` | 表示其前面的字符至少出现n次，最多出现m次。例如：`[a-z]\{6,8\} `匹配6到8位的小写字母。 |

```shell
grep "a*" test_rule.txt	#匹配所有内容，包括空白行
grep "aa*" test_rule.txt #匹配至少包含有一个a的行

grep "s.*d" test_rule.txt	#匹配在s和d字母之间有任意字符
grep ".*" test_rule.txt	#匹配所有内容

grep -n "^$" test_rule.txt	#会匹配空白行
grep "s[ao]id" test_rule.txt	#匹配s和i字母中，要不是a、要不是o

grep "^[^a-zA-Z]" test_rule.txt	#匹配不用字母开头的行

grep "sa\{1,3\}i" test_rule.txt	#匹配在字母s和字母i之间有最少一个a，最多三个a
```

扩展字符表达式

省略

#### 10.2 字符截取命令

cut字段截取命令 

```shell
cut [选项] 文件名	#截取列
-f 列号： 提取第几列		#此时分隔符是制表符
-d 分隔符： 按照指定分隔符分割列

cut -f 2,3 student.txt
cut -d ":" -f 1,3 /etc/passwd	

df -h | cut -d " " -f 1,3	#cut命令的局限
#空格为分隔符，需要使用awk命令
```

```shell
printf ’输出类型输出格式’ 输出内容
%ns： 输出字符串。n是数字指代输出几个字符
%ni： 输出整数。n是数字指代输出几个数字
%m.nf： 输出浮点数。m和n是数字，指代输出的整数位数和小数位数。如%8.2f代表共输出8位数，其中2位是小数，6位是整数。
```

输出格式

| 字符 | 代表含义                      |
| ---- | ----------------------------- |
| \a   | 输出警告声音                  |
| \b   | 输出退格键，也就是Backspace键 |
| \f   | 清除屏幕                      |
| \n   | 换行                          |
| \r   | 回车，也就是Enter键           |
| \t   | 水平输出退格键，也就是Tab键   |
| \v   | 垂直输出退格键，也就是Tab键   |



```shell
printf %s 1 2 3 4 5 6
printf '%s %s %s\n' 1 2 3 4 5 6
printf '%s\t %s\t %s\t\n' 1 2 3 4 5 6
```

awk命令的输出中支持print和printf命令

- print：print会在每个输出之后自动加入一个换行符（Linux默认没有print命令）
- printf：printf是标准格式输出命令，并不会自动加入换行符，如果需要换行，需要手工加入换行符

 

```shell
$ awk ‘条件1{动作1} 条件2{动作2}…’ 文件名
#条件（Pattern）：
#一般使用关系表达式作为条件
#x > 10 判断变量 x是否大于10
#x>=10 大于等于
#x<=10 小于等于
#动作（Action）：
#格式化输出
#流程控制语句

$ awk '{printf $2 "\t" $6 "\n"}' student.txt 	#输入出第二列和第六列
$ df -h | awk '{print $1 "\t" $3}'

# 先输出 This is a transcript，在执行后面的内容。
$ awk 'BEGIN{printf "This is a transcript \n" } {printf $2 "\t" $6 "\n"}' student.txt 
$ awk 'END{printf "The End \n" } {printf $2 "\t" $6 "\n"}' student.txt

#手工定义分隔符一定要加BEGIN，否则第一行来不及处理便输出
$ cat /etc/passwd | grep "/bin/bash" | awk 'BEGIN {FS=":"} {printf $1 "\t" $3 "\n"}' 

$ cat student.txt | grep -v Name | awk '$6 >= 87 {printf $2 "\n" }'
```

```shell
#sed 是一种几乎包括在所有 UNIX 平台（包括 Linux）的轻量级流编辑器。sed主要是用来将数据进行选取、替换、删除、新增的命令。

sed [选项] ‘[动作]’ 文件名
选项：
-n： 一般sed命令会把所有数据都输出到屏幕 ，如果加入此选择，则只会把经过sed命令处理的行输出到屏幕。
-e： 允许对输入数据应用多条sed命令编辑
-i： 用sed的修改结果直接修改读取数据的文件，而不是由屏幕输出
```

动作

| 字符串  | 作用                                                         |
| ------- | ------------------------------------------------------------ |
| `a \：` | 追加，在当前行后添加一行或多行。添加多行时，除最后 一行外，每行末尾需要用“\”代表数据未完结。 |
| `c \：` | 行替换，用c后面的字符串替换原数据行，替换多行时，除最后一行外，每行末尾需用“\”代表数据未完结。 |
| `i \：` | 插入，在当期行前插入一行或多行。插入多行时，除最后 一行外，每行末尾需要用“\”代表数据未完结。 |
| `d：`   | 删除，删除指定的行。                                         |
| `p：`   | 打印，输出指定的行。                                         |
| `s：`   | 字串替换，用一个字符串替换另外一个字符串。格式为“行范围s/旧字串/新字串/g”（和vim中的替换格式类似）。 |

```shell
$ df | sed '3p'		#输出第三行的同时将所有数据也输出了一遍
$ df | sed -n '3p'

#不修改文件本身,只是改变数据的输出
$ sed '2,4d' student.txt	#删除第二行到第四行的数据
$ sed '2a hello' student.txt	#在第二行后追加hello
$ sed '2i hello world' student.txt	#在第二行前插入两行数据
$ sed '2c No such person' student.txt	#数据替换，将第二行替换为No such person
$ sed '3s/74/99/g' student.txt	#在第三行中，把74换成99

$ sed -i '3s/74/99/g' student.txt	#-i,sed操作的数据直接写入文件
$ sed -e 's/Liming//g ; s/Gao//g' student.txt	#同时把“Liming”和“Gao”替换为空,s不加行号代表整篇文档，
```



#### 10.3 字符处理命令

```shell
sort [选项] 文件名	#排序命令
选项：
-f： 忽略大小写
-n： 以数值型进行排序，默认使用字符串型排序
-r： 反向排序
-t： 指定分隔符，默认是分隔符是制表符
-k n[,m]： 按照指定的字段范围排序。从第n字段开始，m字段结束（默认到行尾）
```

```shell
sort /etc/passwd	#排序用户信息文件
sort -r /etc/passwd	#反向排序
$ sort -t ":" -k 3,3 /etc/passwd	#指定分隔符是“：”，用第三字段开头，第三字段结尾排
序，就是只用第三字段排序
$ sort -n -t ":" -k 3,3 /etc/passwd
```

```shell
 wc [选项] 文件名	#统计命令
选项：
-l： 只统计行数
-w： 只统计单词数
-m： 只统计字符数
```

#### 10.4 条件判断

按照文件类型进行判断

| 测试选项 | 作 用                                                        |
| -------- | ------------------------------------------------------------ |
| -b 文件  | 判断该文件是否存在，并且是否为块设备文件（是块设备文件为真） |
| -c文件   | 判断该文件是否存在，并且是否为字符设备文件（是字符设备文件为真） |
| -d 文件  | 判断该文件是否存在，并且是否为目录文件（是目录为真）         |
| -e 文件  | 判断该文件是否存在（存在为真）                               |
| -f 文件  | 判断该文件是否存在，并且是否为普通文件（是普通文件为真）     |
| -L 文件  | 判断该文件是否存在，并且是否为符号链接文件（是符号链接文件为真） |
| -p 文件  | 判断该文件是否存在，并且是否为管道文件（是管道文件为真）     |
| -s 文件  | 判断该文件是否存在，并且是否为非空（非空为真）               |
| -S 文件  | 判断该文件是否存在，并且是否为套接字文件（是套接字文件为真） |

```shell
$ test -e /root/install.log	#通过 echo$? 查看上一条命令的执行结果
$ [ -e /root/install.log ]	#注意空格

$ [ -d /root ] && echo "yes" || echo "no"	#第一个判断命令如果正确执行，则打印“yes”，否则打印“no”
```

按照文件权限进行判断

| 测试选项 | 作 用                                                        |
| -------- | ------------------------------------------------------------ |
| -r 文件  | 判断该文件是否存在，并且是否该文件拥有读权限（有读权限为真） |
| -w 文件  | 判断该文件是否存在，并且是否该文件拥有写权限（有写权限为真） |
| -x 文件  | 判断该文件是否存在，并且是否该文件拥有执行权限（有执行权限为真） |
| -u 文件  | 判断该文件是否存在，并且是否该文件拥有SUID权限（有SUID权限为真） |
| -g 文件  | 判断该文件是否存在，并且是否该文件拥有SGID权限（有SGID权限为真） |
| -k 文件  | 判断该文件是否存在，并且是否该文件拥有SBit权限（有SBit权限为真） |

```shell
$ [ -w student.txt ] && echo "yes" || echo "no"	#判断文件是拥有写权限的,不区分身份
```

两个文件之间进行比较

| 测试选项        | 作 用                                                        |
| --------------- | ------------------------------------------------------------ |
| 文件1 -nt 文件2 | 判断文件1的修改时间是否比文件2的新（如果新则为真）           |
| 文件1 -ot 文件2 | 判断文件1的修改时间是否比文件2的旧（如果旧则为真）           |
| 文件1 -ef 文件2 | 判断文件1是否和文件2的Inode号一致，可以理解为两个文件是否为同一个文件。这个判断用于判断硬链接是很好的方法 |

```shell
ln /root/student.txt /tmp/stu.txt	#创建个硬链接吧
#用test测试下，果然很有用
[ /root/student.txt -ef /tmp/stu.txt ] && echo "yes" || echo "no" yes
```

两个整数之间比较

| 测试选项        | 作 用                                      |
| --------------- | ------------------------------------------ |
| 整数1 -eq 整数2 | 判断整数1是否和整数2相等（相等为真）       |
| 整数1 -ne 整数2 | 判断整数1是否和整数2不相等（不相等位置）   |
| 整数1 -gt 整数2 | 判断整数1是否大于整数2（大于为真）         |
| 整数1 -lt 整数2 | 判断整数1是否小于整数2（小于位置）         |
| 整数1 -ge 整数2 | 判断整数1是否大于等于整数2（大于等于为真） |
| 整数1 -le 整数2 | 判断整数1是否小于等于整数2（小于等于为真） |

```shell
[ 23 -ge 22 ] && echo "yes" || echo "no"	#判断23是否大于等于22，当然是了
[ 23 -le 22 ] && echo "yes" || echo "no"	#判断23是否小于等于22，当然不是了
```

字符串的判断

| 测试选项       | 作 用                                          |
| -------------- | ---------------------------------------------- |
| -z 字符串      | 判断字符串是否为空（为空返回真）               |
| -n 字符串      | 判断字符串是否为非空（非空返回真）             |
| 字串1 ==字串2  | 判断字符串1是否和字符串2相等（相等返回真）     |
| 字串1 != 字串2 | 判断字符串1是否和字符串2不相等（不相等返回真） |

```shell
name=sc		#给name变量赋值
[ -z "$name" ] && echo "yes" || echo "no"
#判断name变量是否为空，因为不为空，所以返回no

aa=11
bb=22	#给变量aa和变量bb赋值
#判断两个变量的值是否相等，明显不相等，所以返回no,注意空格
[ "$aa" == "bb" ] && echo "yes" || echo "no"
```

多重条件判断

| 测试选项       | 作 用                                                 |
| -------------- | ----------------------------------------------------- |
| 判断1 -a 判断2 | 逻辑与，判断1和判断2都成立，最终的结果才为真          |
| 判断1 -o 判断2 | 逻辑或，判断1和判断2有一个成立，最终的结果就为<br/>真 |
| ！判断         | 逻辑非，使原始的判断式取反                            |

```shell
$ aa=11
$ [ -n "$aa" -a "$aa" -gt 23 ] && echo "yes" || echo "no"

#判断变量aa是否有值，同时判断变量aa的是否大于23
#因为变量aa的值不大于23，所以虽然第一个判断值为真，返回的结果也是假
$ aa=24
$ [ -n "$aa" -a "$aa" -gt 23 ] && echo "yes" || echo "no"
```

#### 10.5 流程控制

```shell
if [ 条件判断式 ];then
	程序
fi
或者
if [ 条件判断式 ]
	then
		程序
fi

if [ 条件判断式 ]
	then
		条件成立时，执行的程序
	else
		条件不成立时，执行的另一个程序
fi

if [ 条件判断式1 ]
	then
		当条件判断式1成立时，执行程序1
elif [ 条件判断式2 ]
	then
		当条件判断式2成立时，执行程序2
···省略更多条件…
else
	当所有条件都不成立时，最后执行此程序
fi
```

- if语句使用fi结尾，和一般语言使用大括号结尾不同
- [ 条件判断式 ]就是使用test命令判断，所以中括号和条件判断式之间必须有空格
- then后面跟符合条件之后执行的程序，可以放在[]之后，用“；”分割。也可以换行写入，就不需要“；”了

```shell
#!/bin/bash
#统计根分区使用率
# Author: shenchao （E-mail: shenchao@lampbrother.net）
rate=$(df -h | grep "/dev/sda3" | awk '{print $5}' | cut -d "%" -f1)
#把根分区使用率作为变量值赋予变量rate

if [ $rate -ge 80 ]
 then
  echo "Warning! /dev/sda3 is full!!"
 fi
```



```shell
case $变量名 in
	"值1"）
		如果变量的值等于值1，则执行程序1
		;;
	"值2"）
		如果变量的值等于值2，则执行程序2
		;;
	…省略其他分支…
	*）
	如果变量的值都不是以上的值，则执行此程序
		;;
esac
```

```shell
for 变量 in 值1 值2 值3		#可以用变量来替代
	do
		程序
	done
	
for ((初始值；循环控制条件；变量变化))
	do
		程序
	done

```

```shell
#!/bin/bash
#从1加到100
# Author：abcd

s=0
for ((i=1;i<=100;i=i+1))
	do
		s=$(($s+$i))
	done
echo "The sum of 1+2+3+...+100 is:$s"
```



```shell
while [ 条件判断式 ]
do
程序
done
```

```shell
until [ 条件判断式 ]
do
程序
done
```

```shell
#!/bin/bash
#从1加到100
# Author: shenchao （E-mail: shenchao@lampbrother.net）
i=1
s=0
while [ $i -le 100 ]
#如果变量i的值小于等于100，则执行循环
	do
 		s=$(( $s+$i ))
		i=$(( $i+1 ))
	done
echo "The sum is: $s"
```

### 