---
title: Linux 兄弟连
date: 2019-08-16 15:48:55
tags: [兄弟连, Linux]
---

## Linux 兄弟连

### 1. Linux 系统简介

省略

> LAMP： 支撑互联网的开源技术
>
> - Linux	操作系统
> - Apache Web服务器
> - MySQL 数据库
> - PHP      编程语言

### 2. Linux 系统安装

硬件设备文件名

| 硬 件             | 设备文件名             |
| ----------------- | ---------------------- |
| IDE硬盘           | /dev/hd[a-d]           |
| SCSI/SATA/USB硬盘 | /dev/sd[a-p]           |
| 光驱              | /dev/cdrom 或 /dev/hdc |
| 软盘              | /dev/fd[0-1]           |
| 打印机（25针）    | /dev/lp[0-2]           |
| 打印机（USB）     | /dev/usb/lp[0-15]      |
| 鼠标              | /dev/mouse             |

安装日志

- /root/install.log：存储了安装在系统中的软件包及其版本信息
- /root/install.log.syslog：存储了安装过程中留下的事件记录
- /root/anaconda-ks.cfg：以Kickstart配置文件的格式记录安装过程中设置的选项信息

#### 1). Linux注意事项

1. Linux严格区分大小写
   - Linux中所有内容以文件形式保存，包括硬件
2. Linux不靠扩展名区分文件类型
   - 压缩包：“*.gz”、“*.bz2” *.tar.bz2”、“*.tgz”等
   - 二进制软件包：“.rpm”
   - 网页文件：“*.html”、“*.php”
   - 脚本文件：“*.sh”*
   - *配置文件：“*.conf”
3. Linux所有的存储设备都必须挂载之后用户才能使用，包括硬盘、U盘和光盘
   - Windows下的程序不能直接在Linux中安
     装和运行

#### 2). 服务器管理和维护建议

| 目录名       | 目录作用                                                     |
| ------------ | ------------------------------------------------------------ |
| /bin/        | 存放系统命令的目录，普通用户和超级用户都可以执行。不过放在/bin下的命令在单用户模式下也可以执行 |
| /sbin/       | 保存和系统环境设置相关的命令，只有超级用户可以使用这些命令进行系统环境设置，但是有些命令可以允许普通用户查看 |
| /usr/bin/    | 存放系统命令的目录，普通用户和超级用户都可以执行。这些命令和系统启动无关，在单用户模式下不能执行 |
| /usr/sbin/   | 存放根文件系统不必要的系统管理命令，例如多数服务程序。只有超级用户可以使用。大家其实可以注意到Linux的系统，在所有“sbin”目录中保存的命令只有超级用户可以使用，“bin”目录中保存的命令所有用户都可以使用 |
| /boot/       | 系统启动目录，保存系统启动相关的文件，如内核文件和启动引导程序（grub）文件等 |
| /dev/        | 设备文件保存位置。我们已经说过Linux中所有内容以文件形式保存，包括硬件。那么这个目录就是用来保存所有硬件设备文件的 |
| /etc/        | 配置文件保存位置。系统内所有采用默认安装方式（rpm安装）的服务的配置文件全部都保存在这个目录当中，如用户账户和密码，服务的启动脚本，常用服务的配置文件等 |
| /home/       | 普通用户的家目录。建立每个用户时，每个用户要有一个默认登录位置，这个位置就是这个用户的家目录，所有普通用户的家目录就是在/home下建立一个和用户名相同的目录。如用户user1的家目录就是/home/user1 |
| /lib/        | 系统调用的函数库保存位置                                     |
| /lost+found/ | 当系统意外崩溃或机器意外关机，而产生一些文件碎片放在这里。当系统启动的过程中fsck工具会检查这里，并修复已经损坏的文件系统。这个目录只在每个分区中出现，例如/lost+found就是根分区的备份恢复目录，/boot/lost+found就是/boot分区的备份恢复目录 |
| /media/      | 挂载目录。系统建议是用来挂载媒体设备的，例如软盘和光盘       |
| /mnt/        | 挂载目录，早期Linux中只有这一个挂载目录，并没有细分。现在这个目录系统建议挂载额外设备，如U盘，移动硬盘和其他操作系统的分区 |
| /misc/       | 挂载目录。系统建议用来挂载NFS服务的共享目录。我们在刚刚已经解释了挂载，童鞋们应该知道只要是一个已经建立的空目录就可以作为挂载点。那么系统虽然准备了三个默认挂载目录/media、/mnt、/misc，但是到底在哪个目录中挂载什么设备都可以由管理员自己决定。例如超哥接触Linux的时候，默认挂载目录只有/mnt一个，所以养成了在/mnt下建立不同目录挂载不同设备的习惯。如/mnt/cdrom挂载光盘，/mnt/usb挂载U盘，这都是可以的 |
| /opt/        | 第三方安装的软件保存位置。这个目录就是放置和安装其他软件的位置，我手工安装的源码包软件都可以安装到这个目录当中。不过我还是更加习惯把软件放置到/usr/local/目录当中，也就是说/usr/local/目录也可以用来安装软件 |
| /proc/       | 虚拟文件系统，该目录中的数据并不保存到硬盘当中，而是保存到内存当中。主要保存系统的内核，进程，外部设备状态和网络状态灯。如/proc/cpuinfo是保存CPU信息的，/proc/devices是保存设备驱动的列表的，/proc/filesystems是保存文件系统列表的，/proc/net/是保存网络协议信息的 |
| /sys/        | 虚拟文件系统。和/proc目录相似，都是保存在内存当中的，主要是保存于内核相关信息的 |
| /root/       | 超级用户的家目录。普通用户家目录在“/home”下，超级用于家目录直接在“/”下 |
| /srv/        | 服务数据目录。一些系统服务启动之后，可以在这个目录中保存所需要的数据 |
| /tmp/        | 临时目录。系统存放临时文件的目录，该目录下所有用户都可以访问和写入。我们建议此目录中不能保存重要数据，最好每次开机都把该目录清空 |
| /usr/        | 系统软件资源目录。注意usr不是user的缩写，而是“Unix SoftwreResource”的缩写，所以不是存放用户数据，而是存放系统软件资源的目录。系统中安装的软件大多数保存在这里，所以除了/usr/bin/和/usr/sbin/这两个目录，我在介绍几个/usr/下的二级目录 |
| /var/        | 动态数据保存位置。主要保存缓存、日志以及软件运行所产生的文件 |

- 远程服务器不允许关机，只能重启
- 重启时应该关闭服务
- 不要在服务器访问高峰运行高负载命令
- 远程配置防火墙时不要把自己踢出服务器
- 指定合理的密码规范并定期更新
- 合理分配权限
- 定期备份重要数据和日志

### 3. Linux常用命令

#### 3.1 文件处理命令

```shell
ls -la /etc		#list
语法：ls 选项[-ald] [文件或目录]
-a 显示所有文件，包括隐藏文件
-l 详细信息显示
-d 查看目录属性

-rw-r--r--
 - 文件类型（- 文件 d 目录 l 软链接文件）
 rw- r-- r--
 u   g   o
 u所有者 g所属组 o其他人
 r读 w写 x执行
```

```shell
mkdir -p [目录名] 	#功能描述：创建新目录
-p 递归创建
mkdir -p /tmp/Japan/boduo
mkdir /tmp/Japan/longze /tmp/Japan/cangjing
```

```shell
cd [目录]		#功能描述：切换目录，shell内置命令
cd /tmp/Japan/boduo 切换到指定目录
cd .. 回到上一级目录
```

```shell
pwd		#功能描述：显示当前目录 print working directory
```

```shell
rmdir	#功能描述： 删除空目录，remove empty directories
rmdir /tmp/Japan/boduo 
```

```shell
cp		#功能描述：复制文件或目录
语法：cp -rp [原文件或目录] [目标目录]
-r 复制目录
-p 保留文件属性
```

```shell
mv [原文件或目录] [目标目录]		#功能描述：剪切文件、改名
```

```shell
rm -rf [文件或目录]		#功能描述：删除文件
-r 删除目录
-f 强制执行
```

```
touch		#功能描述：创建空文件
```

```shell
cat [文件名]	#功能描述：显示文件内容
 -n 显示行号
范例： $ cat /etc/issue

tac [文件名]	#功能描述：显示文件内容（反向列示）
范例： $ tac /etc/issue
```

```shell
more [文件名]	#功能描述：分页显示文件内容
 (空格) 或f 翻页
 (Enter) 换行
 q或Q 退出
范例： $ more /etc/services

less [文件名]	#功能描述：分页显示文件内容（可向上翻页）
范例： $ less /etc/services
```

```shell
head [文件名]	#功能描述：显示文件前面几行
-n 指定行数
范例： $ head -n 20 /etc/services

tail [文件名]	#功能描述：显示文件后面几行
-n 指定行数
-f 动态显示文件末尾内容
范例： $ tail -n 18 /etc/services
```

```shell
ln -s [原文件] [目标文件]	#功能描述：生成链接文件
 -s 创建软链接

范例：
 $ ln -s /etc/issue /tmp/issue.soft
 创建文件/etc/issue的软链接/tmp/issue.soft
 $ ln /etc/issue /tmp/issue.hard
 创建文件/etc/issue的硬链接/tmp/issue.hard
```

##### 软链接特征：

类似Windows快捷方式

1、lrwxrwxrwx l 软链接，软链接文件权限都为rwxrwxrwx
2、文件大小-只是符号链接
3、/tmp/issue.soft -> /etc/issue箭头指向原文件

##### 硬链接特征：
1、拷贝cp -p + 同步更新 echo "this is a test" >> /etc/motd
2、可通过i节点识别
3、不能跨分区
4、不能针对目录使用



#### 3.2 权限管理命令

```shell
chmod [{ugoa}{+-=}{rwx}] [文件或目录]
 [mode=421 ] [文件或目录]
 -R 递归修改
chmod g+w testfile
chmod -R 777 testdir
```

| 字符 | 权限     | 对文件的含义     | 对目录的含义               | 数字 |
| ---- | -------- | ---------------- | -------------------------- | ---- |
| r    | 读权限   | 可以查看文件内容 | 可以列出目录中的内容       | 4    |
| w    | 写权限   | 可以修改文件内容 | 可以在目录中创建、删除文件 | 2    |
| x    | 执行权限 | 可以执行文件     | 可以进入目录               | 1    |

```shell
chown [用户] [文件或目录]		#功能描述：改变文件或目录的所有者
范例：$ chown dong file		#改变文件file的所有者为dong
chown a:b file
```

```shell
chgrp [用户组] [文件或目录]		#功能描述：改变文件或目录的所属组
范例：$ chgrp dong file	#改变文件file的所属组为dong
```

```shell
umask [-S]			#功能描述：显示、设置文件的缺省权限,the user file-creation mask
 -S 以rwx形式显示新建文件缺省权限
范例： $ umask -S 
```

#### 3.3 文件搜索命令

```shell
find [搜索范围] [匹配条件]		#功能描述：文件搜索
$ find /etc -name init		#在目录/etc中查找文件init
 -iname 不区分大小写
 $ find / -size +204800		#在根目录下查找大于100MB的文件
 +n 大于 -n 小于 n 等于
 $ find /home -user shenchao	#在根目录下查找所有者为shenchao的文件
 -group 根据所属组查找
 
 $ find /etc -cmin -5	#在/etc下查找5分钟内被修改过属性的文件和目录
 -amin 访问时间 access
 -cmin 文件属性 change
 -mmin 文件内容 modify
 
 $ find /etc -size +163840 -a -size -204800	#在/etc下查找大于80MB小于100MB的文件
 -a 两个条件同时满足
 -o 两个条件满足任意一个即可
 $ find /etc -name inittab -exec ls -l {} \;	#在/etc下查找inittab文件并显示其详细信息
 -exec/-ok 命令 {} \; 对搜索结果执行操作
 
 -type 根据文件类型查找
 f 文件 d 目录 l 软链接文件
 -inum 根据i节点查找
```

```shell
locate 文件名	#功能描述：在文件资料库中查找文件
范例：$ locate inittab
updatedb	#需要updatedb更新数据库
```

```shell
which 命令	#功能描述：搜索命令所在目录及别名信息
范例：$ which ls 
```

```shell
whereis [命令名称]	#功能描述：搜索命令所在目录及帮助文档路径
范例：$ whereis ls 
```

```shell
grep -iv [指定字串] [文件]	#功能描述：在文件中搜寻字串匹配的行并输出
 -i 不区分大小写
 -v 排除指定字串
范例：# grep mysql /root/install.log
```



#### 3.4 帮助命令

```shell
man [命令或配置文件]	#功能描述：获得帮助信息，mannul
范例： $ man ls	#查看ls命令的帮助信息
 $ man services	 #查看配置文件services的帮助信息
```

```shell
help 命令	#功能描述：获得Shell内置命令的帮助信息
范例： $ help umask	#查看umask命令的帮助信息
```

#### 3.5 用户管理命令

```shell
useradd 用户名	#功能描述：添加新用户
范例： $ useradd dong2
```

```shell
passwd 用户名	#功能描述：设置用户密码
范例： $ passwd dong2
```

```shell
who		#功能描述：查看登录用户信息
范例： $ who
```

```shell
w		#功能描述：查看登录用户详细信息
范例： $ w
```

#### 3.6 压缩解压命令

```shell
gzip [文件]		#功能描述：压缩文件，GNU zip，压缩后文件格式：.gz
```

```shell
gunzip [压缩文件]	#功能描述：解压缩.gz的压缩文件
范例： $ gunzip boduo.gz 
```

```shell
tar 选项[-zcf] [压缩后文件名] [目录]	#功能描述：打包目录，压缩后文件格式：.tar.gz 
 -c 打包
 -v 显示详细信息
 -f 指定文件名
 -z 打包同时压缩
 $ tar -zcf dir.tar.gz dir	#将目录dir打包并压缩为.tar.gz文件
 
 -x 解包
 -z 解压缩
 $ tar -zxvf dir.tar.gz	#压缩解压
```

```shell
zip 选项[-r] [压缩后文件名] [文件或目录]	#功能描述：压缩文件或目录，压缩后文件格式：.zip 
 -r 压缩目录
$ zip file.zip file	#压缩文件
$ zip -r dir.zip dir	#压缩目录
```

```shell
unzip [压缩文件]	#功能描述：解压.zip的压缩文件
范例：$ unzip test.zip 
```

```shell
bzip2 选项 [-k] [文件]		#功能描述：压缩文件，压缩后文件格式：.bz2
 -k 产生压缩文件后保留原文件
 $ bzip2 -k file
 $ tar -cjf dir.tar.bz2 dir
```

```shell
bunzip2 选项 [-k] [压缩文件]	#功能描述：解压缩
 -k 解压缩后保留原文件
 $ bunzip2 -k file.bz2
 $ tar -xjf dir.tar.bz2
```

#### 3.7 网络命令

```shell
write <用户名>	#功能描述：给用户发信息，以Ctrl+D保存结束
范例： $ write linzhiling 
```

```shell
wall [message]	#功能描述：发广播信息,write all
范例： $ wall ShenChao is a honest man!
```

```shell
ping 选项 IP地址	#功能描述：测试网络连通性
 -c 指定发送次数
范例： $ ping 192.168.1.156 
```

```shell
ifconfig 网卡名称 IP地址	#功能描述：查看和设置网卡信息,interface configure
范例：$ ifconfig eth0 192.168.8.250
```

```shell
mail [用户名]	#功能描述：查看发送电子邮件
范例：$ mail root
```

```shell
last	#功能描述：列出目前与过去登入系统的用户信息
范例：$ last
```

```shell
lastlog	#功能描述：检查某特定用户上次登录的时间
范例：$ lastlog
 $ lastlog -u 502
```

```shell
traceroute	#功能描述：显示数据包到主机间的路径
范例：$ traceroute www.lampbrother.net
```

```shell
netstat [选项]	#功能描述：显示网络相关信息
-t ： TCP协议
-u ： UDP协议
-l ： 监听
-r ： 路由
-n ： 显示IP地址和端口号
范例：
$ netstat -tlun 查看本机监听的端口
$ netstat -an 查看本机所有的网络连接
$ netstat -rn 查看本机路由表
```

```shell
setup	#功能描述：配置网络
范例：$ setup
```

```shell
mount [-t 文件系统] 设备文件名 挂载点	#挂载命令
范例：$ mount -t iso9660 /dev/sr0 /mnt/cdrom
```



#### 3.8 关机重启命令

```shell
shutdown [选项] 时间
选项：
-c： 取消前一个关机命令
-h： 关机
-r： 重启
```

```shell
#其他关机命令
halt
poweroff
init 0	#不同状态好像是

#其他重启命令
reboot
init 6
```

系统运行级别

| 级别 | 作用                      |
| ---- | ------------------------- |
| 0    | 关机                      |
| 1    | 单用户                    |
| 2    | 不完全多用户，不含NFS服务 |
| 3    | 完全多用户                |
| 4    | 未分配                    |
| 5    | 图形界面                  |
| 6    | 重启                      |

```shell
cat /etc/inittab	#修改系统默认运行级别，id:3:initdefault
runlevel			#查询系统运行级别
```

```shell
logout	#退出登陆
```



### 4. 文本编辑器

#### vim

插入命令

| 命令 | 作用                 |
| ---- | -------------------- |
| a    | 在光标所在字符后插入 |
| A    | 在光标所在行尾插入   |
| i    | 在光标所在字符前插入 |
| I    | 在光标所在行行首插入 |
| o    | 在光标下插入新行     |
| O    | 在光标上插入新行     |

定位命令

| 命令       | 作用                    |
| ---------- | ----------------------- |
| : set nu   | 设置行号                |
| : set nonu | 取消行号                |
| gg<br/>G   | 到第一行<br/>到最后一行 |
| nG         | 到第n行                 |
| : n        | 到第n行                 |
| $          | 移至行尾                |
| 0          | 移至行首                |

删除命令

| 命令    | 作用                         |
| ------- | ---------------------------- |
| x       | 删除光标所在处字符           |
| nx      | 删除光标所在处后n个字符      |
| dd      | 删除光标所在行，ndd删除n行   |
| dG      | 删除光标所在行到文件末尾内容 |
| D       | 删除光标所在处到行尾内容     |
| :n1,n2d | 删除指定范围的行             |

复制和剪切命令

| 命令 | 作用                         |
| ---- | ---------------------------- |
| yy   | 复制当前行                   |
| nyy  | 复制当前行以下n行            |
| dd   | 剪切当前行                   |
| ndd  | 剪切当前行以下n行            |
| p、P | 粘贴在当前光标所在行下或行上 |

替换和取消命令

| 命令 | 作用                                |
| ---- | ----------------------------------- |
| r    | 取代光标所在处字符                  |
| R    | 从光标所在处开始替换字符，按Esc结束 |
| u    | 取消上一步操作                      |

搜索和搜索替换命令

| 命令               | 作用                                        |
| ------------------ | ------------------------------------------- |
| /string            | 搜索指定字符串<br/>搜索时忽略大小写 :set ic |
| n                  | 搜索指定字符串的下一个出现位置              |
| :%s/old/new/g 全文 | 全文替换指定字符串                          |
| :n1,n2s/old/new/g  | 在一定范围内替换指定字符串                  |

保存和退出命令

| 命令            | 作用                                     |
| --------------- | ---------------------------------------- |
| :w              | 保存修改                                 |
| :w new_filename | 另存为指定文件                           |
| :wq             | 保存修改并退出                           |
| ZZ              | 快捷键，保存修改并退出                   |
| :q!             | 不保存修改退出                           |
| :wq!            | 保存修改并退出（文件所有者及root可使用） |

 Vim使用技巧

```shell
r !命令	#导入命令执行结果 :
:map 快捷键 触发命令	#定义快捷键 
# 范例：
 : map ^P I#<ESC>
 : map ^B 0x
 
#连续行注释，:{作用范围}s/{目标}/{替换}/{替换标志}
 :n1,n2s/^/#/g
 :n1,n2s/^#//g
 :n1,n2s/^/\/\//g

# 替换
:ab mymail samlee@lampbrother.net
```

### 5. 软件包管理简介

#### 5.1 软件包管理简介

- 源码包
  - 脚本安装包
- 二进制包（RPM包、系统默认包）

#### 5.2 RPM包管理-rpm命令管理

RPM包命名原则

httpd-2.2.15-15.el6.centos.1.i686.rpm
httpd-----------软件包名
2.2.15---------软件版本
15--------------软件发布的次数
el6.centos----适合的Linux平台
i686------------适合的硬件平台
rpm-------------rpm包扩展名

RPM包依赖性

- 树形依赖： a->b->c
- 环形依赖： a->b->c->a
- 模块依赖： 模块依赖查询网站：www.rpmfind.net

包全名：操作的包是没有安装的软件包时，使用包全名。而且要注意路径
包名：操作已经安装的软件包时，使用包名。是搜索/var/lib/rpm/中的数据库

```shell
rpm –ivh 包全名	#RPM安装
选项：
-i（install） 安装
-v（verbose） 显示详细信息
-h（hash） 显示进度
--nodeps 不检测依赖性
```

```shell
rpm -Uvh 包全名	#RPM包升级
选项：
-U（upgrade） 升级
```

```shell
rpm -e 包名		#卸载
选项：
-e（erase） 卸载
--nodeps 不检查依赖性
```

```shell
 rpm -q 包名		#查询包是否安装
选项：
-q 查询（query）

$ rpm –qa		#查询所有已经安装的RPM包
选项：
-a 所有（all）
```

```shell
rpm –qi 包名		#查询软件包详细信息
选项：
-i 查询软件信息（information）
-p 查询未安装包信息（package）
```

```shell
rpm –ql 包名		#查询包中文件安装位置
选项：
-l 列表（list）
-p 查询未安装包信息（package）
```

```shell
rpm –qf 系统文件名	#查询系统文件属于哪个RPM包
选项：
-f 查询系统文件属于哪个软件包（file）
```

```shell
rpm –qR 包名		#查询软件包的依赖性
选项：
-R 查询软件包的依赖性（requires）
-p 查询未安装包信息（package）
```

```shell
 rpm –V 已安装的包名
选项：
-V 校验指定RPM包中的文件（verify）
```

验证内容中的8个信息的具体内容如下：

- S 文件大小是否改变
- M 文件的类型或文件的权限（rwx）是否被改变
- 5 文件MD5校验和是否改变（可以看成文件内容是否改变）
- D 设备的中，从代码是否改变
- L 文件路径是否改变
- U 文件的属主（所有者）是否改变
- G 文件的属组是否改变
- T 文件的修改时间是否改变

文件类型

- c 配置文件（config file）
- d 普通文档（documentation）
- g “**鬼”文件**（ghost file），很少见，就是该文件不应该被这个RPM包包含
- l 授权文件（license file）
- r 描述文件（read me）

```shell
.rpm2cpio 包全名 | cpio -idv .文件绝对路径
rpm2cpio
#将rpm包转换为cpio格式的命令
cpio
#是一个标准工具，它用于创建软件档案文件和从档案文件中提取文件
```

```shell
cpio 选项 < [文件|设备]
选项：
-i：copy-in模式，还原
-d：还原时自动新建目录
-v：显示还原过程
```

```shell
rpm -qf /bin/ls		#查询ls命令属于哪个软件包
mv /bin/ls /tmp/	#造成ls命令误删除假象
rpm2cpio /mnt/cdrom/Packages/coreutils8.4-19.el6.i686.rpm | cpio -idv ./bin/ls
#提取RPM包中ls命令到当前目录的/bin/ls下
[root@localhost ~]# cp /root/bin/ls /bin/	#把ls命令复制会/bin/目录，修复文件丢失
```



#### 5.3RPM包管理-yum在线管理



#### 5.4 源码包管理

#### 5.5脚本安装包与软件包选择

### 6. 用户和用户组管理

### 7. 权限管理

### 8. 文件管理系统



------

#### ACL权限

> 查看分区ACL权限是否开启
>
> ```shell
> dumpe2fs -h /dev/sda3	#dumpe2fs命令是查询指定分区详细文件系统信息的命令
> ```
>
> 临时开启分区ACL权限
>
> ```shell
> mount -o remount,acl /	#重新挂载根分区，并挂载加入acl权限
> ```
>
> 永久开启分区ACL权限
>
> ```shell
> vi /etc/fstab			#加入acl,不过默认一般带有acl权限
> mount -o remount /		#重新挂载文件系统或重启动系统，使修改生效
> ```
>
> 
>
> 查看ACL命令
>
> ```shell
> getfacle 文件名		#查看acl权限
> ```
>
> 设定ACL权限的命令
>
> ```shell
> setfacl 选项 文件名	
> setfacl -m u:dong:rx /home/dong/hello/getfacl hello/ #u为用户，g为group
> setfacl -m m:rx 文件名		  #最大有效权限mask
> setfacl -x u:用户名 文件名	#删除指定acl权限
> setfacl -b 文件名			  #删除文件所有acl权限
> setfacl -m u:用户名:权限 -R 文件名	#递归ACL权限
> setfacl -m d:u:用户名:权限 文件名	#默认ACL权限
> ```
>
> 

#### 文件特殊权限

> 设定SetUID的方法
>
> ```shell
> chmod 4777 文件名
> chmod u+s 文件名
> chmod 755 文件名 	#取消SetUID
> chmod u-s 文件名	#取消SetUID
> ```
>
> 
>
> ```
> chmod 2777 文件名
> chmod g+s 文件名
> chmod 1755 目录名
> chmod o+t 目录名
> ```
>
> 
>
> 
>
> 
>
> 
>
> 
>
> 
>
> vi /etc/fstabmount -o remount /

**文件系统属性chattr权限**chattr [+-=] [选项] 文件或目录名 （针对root用户生效）
lsattr 选项 文件名
**系统命令sudo权限**visudo
sudo -lsudo /shin/shutdown -r now
**文件系统管理**
#df        #看系统剩余空间（程序运行也会占用空间）#df -T -h  #看文件系统类型#du -sh /tmp/        #文件大小#fsck#dumpe2fs    #注意需要是ext文件系统#mount -l#mount -a    #挂载命令
#mount [-t 文件系统] [-L 卷标名] [-o 特殊选项] 设备文件名 挂载点#mount -o remount,noexec /home
media挂光盘 mnt挂U盘
#mkdir /mnt/cdrom#mount -t ios9660 /dev/cdrom mnt/cdrom/#mount /dev/sr0 /mnt/cdrom/#umount 设备文件名或挂载点挂载U盘 linux默认不支持NTFS文件系统#fdisk -l

p

**以上回头再整理，我现在不想看**



### 9. Shell基础

> Shell的两种主要语法类型有Bourne和C，这两种语法彼此不兼容。
>
> 1. Bourne家族主要包括sh、ksh、**Bash**、psh、zsh；
> 2. C家族主要包括：csh、tcsh

#### linux支持的shells

```shell
cat /etc/shells		#输入shell的标识名可以互相切换(单用户，系统修复模式启动的shell就是sh)
sh			#进入sh shell中
exit		#退出
```

#### shell脚本的执行方式

```shell
#echo 后加！需要单引号
echo "hello world"
echo 'hello world!!!'

#-e 支持\为转义符
echo -e "ab\bc"	
echo -e "\e[1;31m abcd \e[0m" #\e[1;开启颜色输出，\e[0m结束颜色输出

```

第一个脚本

```shell
vim hello.sh
#!/bin/Bash		#标识当前写的程序是shell脚本，并不是注释
#The first program
# Author: shenchao （E-mail: shenchao@lampbrother.net）

echo -e "Mr. Shen Chao is the most honest man in LampBrother"
```

```shell
chmod 755 hello.sh
./hello.sh		#可以用相对路径或绝对路径来执行
bash hello.sh	#调用bash执行，不用执行权限
```

注意，windows下换行符`^M$` CRLF和linux换行符`$`LF不同，可以通过dos2unix来转换。

#### BASH的基本功能

```shell
history
#~/.bash.history中记录的为前一次登录以前的命令，这一次登录的命令被暂存在内存中。
#历史命令默认保存1000行，可在/etc/profile中修改 HISTSIZE
history -c	#清空历史命令
history -w	#强制将缓存中的历史命令写入~/.bash.history
#使用上、下箭头调用以前的历史命令
#使用“!n”重复执行第n条历史命令
#使用“!!”重复执行上一条命令
#使用“!字串”重复执行最后一条以该字串开头的命令

```

```shell
#Tab	命令、文件补全
```

```shell
alias	#查询命令别名
alias lm='ls -al'	#临时生效
vi /root/.bashrc	#永久生效
unalias 别名
```

##### 命令执行顺序

1. 第一顺位执行用绝对路径或相对路径执行的命令。
2. 第二顺位执行别名。
3. 第三顺位执行Bash的内部命令。
4. 第四顺位执行按照$PATH环境变量定义的目录查找顺序找到的第一个命令

##### Bash常用快捷键

| 快捷键 | 作用                                                         |
| ------ | ------------------------------------------------------------ |
| CRTL+C | 强制终止当前的命令。                                         |
| CRTL+L | 清屏，相当于clear命令。                                      |
| CRTL+U | 删除或剪切光标之前的命令。我输入了一行很长的命令，不用使用退格键一个一个字符的删除，使用这个快捷键会更加方便 |
| CRTL+Y | 粘贴ctrl+U或ctrl+K剪切的内容。                               |
| CRTL+R | 在历史命令中搜索，按下ctrl+R之后，就会出现搜索界面，只要输入搜索内容，就会从历史命令中搜索。 |
| CRTL+D | 退出当前终端。                                               |
| CRTL+Z | 暂停，并放入后台。这个快捷键牵扯工作管理的内容，我们在系统管理章节详细介绍。 |

##### 输入输出重定向

标准输入输出

| 设备   | 设备文件名  | 文件描述符 | 类型         |
| ------ | ----------- | ---------- | ------------ |
| 键盘   | /dev/stdin  | 0          | 标准输入     |
| 显示器 | /dev/sdtout | 1          | 标准输出     |
| 显示器 | /dev/sdterr | 2          | 标准错误输出 |

输出重定向

| 类 型                      | 符 号                | 作用                                                         |
| -------------------------- | -------------------- | ------------------------------------------------------------ |
| 标准输出重定向             | 命令 > 文件          | 以覆盖的方式，把命令的、正确输出输出到指定的文、件或设备当中。 |
|                            | 命令 >> 文件         | 以追加的方式，把命令的正确输出输出到指定的文件或设备当中。   |
| 标准错误输出重定向         | 错误命令 2>文件      | 以覆盖的方式，把命令的错误输出输出到指定的文件或设备当中。   |
|                            | 错误命令 2>>文件     | 以追加的方式，把命令的错误输出输出到指定的文件或设备当中。   |
| 正确输出和错误输出同时保存 | 命令 > 文件 2>&1     | 以覆盖的方式，把正确输出和错误输出都保存到同一个文件当中。   |
|                            | 命令 >> 文件 2>&1    | 以追加的方式，把正确输出和错误输出都保存到同一个文件当中。   |
|                            | 命令 &>文件          | 以覆盖的方式，把正确输出和错误输出都保存到同一个文件当中。   |
|                            | 命令 &>>文件         | 以追加的方式，把正确输出和错误输出都保存到同一个文件当中。   |
|                            | 命令>>文件1 2>>文件2 | 把正确的输出追加到文件1中，把错误的输出追加到文件2中。       |

输入重定向

```shell
wc
wc < 文件
wc << 标识符
```

##### 多命令顺序执行与管道符

| 多命令执行符 | 格式             | 作用                                                         |
| ------------ | ---------------- | ------------------------------------------------------------ |
| ;            | 命令1；命令2     | 多个命令顺序执行，命令之间没有任何逻辑联系                   |
| &&           | 命令1 && 命令2   | 逻辑与，当命令1正确执行，则命令2才会执行<br />当命令1执行不正确，则命令2不会执行 |
| \|\|         | 命令1 \|\| 命令2 | 逻辑或，当命令1 执行不正确，则命令2才会执行<br />当命令1正确执行，则命令2不会执行 |

```shell
dd if=输入文件 of=输出文件 bs=字节数 count=个数
date ; dd if=/dev/zero of=/root/testfile bs=1k count=100000 ;date
```

```shell
命令1 | 命令2	#命令1的正确输出作为命令2的操作对象
ll -a /etc/ | more
netstat -an | grep "ESTABLISHED"

```

```shell
grep [选项] "搜索内容" "文件内容"
-i： 忽略大小写
-n： 输出行号
-v： 反向查找
--color=auto 搜索出的关键字用颜色显示

```

##### 通配符与其他特殊符号

| 通配符 | 作 用                                                        |
| ------ | ------------------------------------------------------------ |
| ？     | 匹配一个任意字符                                             |
| *      | 匹配0个或任意多个任意字符，也就是可以匹配任何内容            |
| []     | 匹配中括号中任意一个字符。例如：[abc]代表一定匹配一个字符，或者是a，或者是b，或者是c。 |
| [-]    | 匹配中括号中任意一个字符，-代表一个范围。例如：[a-z]代表匹配一个小写字母。 |
| [^]    | 逻辑非，表示匹配不是中括号内的一个字符。例如：`[^0-9]`代表匹配一个不是数字的字符。 |

| 符 号 | 作 用                                                        |
| ----- | ------------------------------------------------------------ |
| ' '   | 单引号。在单引号中所有的特殊符号，如“$”和“`”(反引号)都没有特殊含义。 |
| " "   | 双引号。在双引号中特殊符号大多数没有特殊含义，但是“$”、“`”和“\”是例外，拥有“调用变量的值”、“引用命令”和“转义符”的特殊含义。 |
| ``    | 反引号。反引号括起来的内容是系统命令，在Bash中会先执行它。和$()作用一样，不过推荐使用$()，因为反引号非常容易看错。 |
| $()   | 和反引号作用一样，用来引用系统命令，但不会被看错。           |
| #     | 在Shell脚本中，#开头的行代表注释。                           |
| $     | 用于调用变量的值，如需要调用变量name的值时，需要用$name的方式得到变量的值。 |
| \     | 转义符，跟在\之后的特殊符号将失去特殊含义，变为普通字符。如\$将输出“$”符号，而不当做是变量引用。 |

#### Bash变量

1. 变量名称可以由字母、数字和下划线组成，但是不能以数字开头。如果变量名是“2name”则是错误的。
2. 在Bash中，**变量的默认类型都是字符串型**，如果要进行数值运算，则必修指定变量类型为数值型。变量用等号连接值，**等号左右两侧不能有空格**。
3. 变量的值如果有空格，需要使用单引号或双引号包括。
4. 在变量的值中，可以使用“\”转义符。
5. 如果需要增加变量的值，那么可以进行变量值的叠加。不过变量需要用双引号包含“$变量名”或用${变量名}包含。
6. 如果是把命令的结果作为变量值赋予变量，则需要使用反引号或$()包含命令。
7. 环境变量名建议大写，便于区分。

变量分类

1. 用户自定义变量。（只在当前shell生效）
2. 环境变量：这种变量中主要保存的是和系统操作环境相关的数据。（当前shell和子shell生效，写入配置文件后，所有shell都生效）
3. 位置参数变量：这种变量主要是用来向脚本当中传递参数或数据的，变量名不能自定义，变量作用是固定的。
4. 预定义变量：是Bash中已经定义好的变量，变量名不能自定义，变量作用也是固定的。

```shell
name="brother dong"	#变量定义-用户自定义变量
echo $name
name="$name"sssss	#变量叠加
name=${name}sssss
set			#变量查看
unset name	#变量删除

```

```shell
yum -y install psmisc 
pstree		#树型显示当前运行的进程。可以看到shell关系

set		#可以看到所有变量，但是我的set为啥嫩奇怪

export 变量名=变量值
#申明变量
env
#查询变量
unset 变量名
#删除变量

```

PATH：系统查找命令的路径

PS1：定义系统提示符的变量

| 符号 | 含义                                                         |
| ---- | ------------------------------------------------------------ |
| \d： | 显示日期，格式为“星期 月 日”                                 |
| \h： | 显示简写主机名。如默认主机名“localhost”                      |
| \t： | 显示24小时制时间，格式为“HH:MM:SS”                           |
| \T： | 显示12小时制时间，格式为“HH:MM:SS”                           |
| \A： | 显示24小时制时间，格式为“HH:MM”                              |
| \u： | 显示当前用户名                                               |
| \w： | 显示当前所在目录的完整名称                                   |
| \W： | 显示当前所在目录的最后一个目录                               |
| \#： | 执行的第几个命令                                             |
| \$： | 提示符。如果是root用户会显示提示符为“#”，如果是普通用户会显示提示符为“$” |

```shell
PS1='[\u@\t \w]\$ '		#临时生效

```

| 位置参数变量 | 作 用                                                        |
| ------------ | ------------------------------------------------------------ |
| $n           | n为数字，$0代表命令本身，$1-$9代表第一到第九个参数，十以上的参数需要用大括号包含，如${10}. |
| $*           | 这个变量代表命令行中所有的参数，$*把所有的参数看成一个整体   |
| $@           | 这个变量也代表命令行中所有的参数，不过$@把每个参数区分对待   |
| $#           | 这个变量代表命令行中所有参数的个数                           |

| 预定义变量 | 作 用                                                        |
| ---------- | ------------------------------------------------------------ |
| $？        | 最后一次执行的命令的返回状态。如果这个变<br/>量的值为0，证明上一个命令正确执行；如果<br/>这个变量的值为非0（具体是哪个数，由命令<br/>自己来决定），则证明上一个命令执行不正确<br/>了。 |
| $$         | 当前进程的进程号（PID）                                      |
| $!         | 后台运行的最后一个进程的进程号（PID）                        |

```shell
#!/bin/bash
# Author: shenchao （E-mail: shenchao@lampbrother.net）
echo "The current process is $$"
#输出当前进程的PID。
#这个PID就是variable.sh这个脚本执行时，生成的进程的PID
find /root -name hello.sh &
#使用find命令在root目录下查找hello.sh文件
#符号&的意思是把命令放入后台执行，工作管理我们在系统管理章节
会详细介绍
echo "The last one Daemon process is $!"

```

接收键盘输入

```shell
read [选项] [变量名]
-p “提示信息”：在等待read输入时，输出提示信息
-t 秒数： read命令会一直等待用户输入，使用
此选项可以指定等待时间
-n 字符数： read命令只接受指定的字符数，就会
执行
-s： 隐藏输入的数据，适用于机密信息的
输入

```



```shell
#!/bin/bash
# Author: shenchao （E-mail: shenchao@lampbrother.net）
read -t 30 -p "Please input your name: " name
#提示“请输入姓名”并等待30秒，把用户的输入保存入变量name中
echo "Name is $name "
read -s -t 30 -p "Please enter your age: " age
#年龄是隐私，所以我们用“-s”选项隐藏输入
echo -e "\n"
echo "Age is $age "
read -n 1 -t 30 -p "Please select your gender[M/F]: "gender
#使用“-n 1”选项只接收一个输入字符就会执行（都不用输入回车）
echo -e "\n"
echo "Sex is $gender"

```

#### Bash运算符

```shell
declare [+/-][选项] 变量名
-： 给变量设定类型属性
+： 取消变量的类型属性
-i： 将变量声明为整数型（integer）
-x： 将变量声明为环境变量
-p： 显示指定变量的被声明的类型

```

```shell
aa=1
bb=2
declare -i cc=$aa+$bb
dd=$(expr $aa + $bb)
#dd的值是aa和bb的和。注意“+”号左右两侧必须有空格
ff=$(( $aa+$bb ))
gg=$[ $aa+$bb ]

```

运算符

| 优先级 | 运算符                              | 说明                               |
| ------ | ----------------------------------- | ---------------------------------- |
| 13     | -, +                                | 单目负、单目正                     |
| 12     | !, ~                                | 逻辑非、按位取反或补码             |
| 11     | * , / , %                           | 乘、除、取模                       |
| 10     | +, -                                | 加、减                             |
| 9      | << , >>                             | 按位左移、按位右移                 |
| 8      | < =, > =, < , >                     | 小于或等于、大于或等于、小于、大于 |
| 7      | == , !=                             | 等于、不等于                       |
| 6      | &                                   | 按位与                             |
| 5      | ^                                   | 按位异或                           |
| 4      | \|                                  | 按位或                             |
| 3      | &&                                  | 逻辑与                             |
| 2      | \|\|                                | 逻辑或                             |
| 1      | =,+=,-=,*=,/=,%=,&=, ^=,=, <<=, >>= | 赋值、运算且赋值                   |

| 变量置换方式 | 变量y没有设置                      | 变量y为空值            | 变量y设置值  |
| ------------ | ---------------------------------- | ---------------------- | ------------ |
| x=${y-新值}  | x=新值                             | x为空                  | x=$y         |
| x=${y:-新值} | x=新值                             | x=新值                 | x=$y         |
| x=${y+新值}  | x为空                              | x=新值                 | x=新值       |
| x=${y:+新值} | x为空                              | x为空                  | x=新值       |
| x=${y=新值}  | x=新值 y=新值                      | x为空 y值不变          | x=$y y值不变 |
| x=${y:=新值} | x=新值 y=新值                      | x=新值 y=新值          | x=$y y值不变 |
| x=${y?新值}  | 新值输出到标准错误输出（就是屏幕） | x为空                  | x=$y         |
| x=${y:?新值} | 新值输出到标准错误输出             | 新值输出到标准错误输出 | x=$y         |

```shell
y=""	#双引号代表为空

```

#### 环境变量配置文件

```shell
source 配置文件
. 配置文件
#两者作用相同，都是让配置文件立即生效。


```

五个系统默认环境变量配置文件

```shell
/etc/profile
/etc/profile.d/*.sh	#这个是一组文件
~/.bash_profile
~/.bashrc
/etc/bashrc

```

![1565858244081](D:\Workspaces\Typora\image\I59.png)

1. /etc/profile的作用：
   - USER变量：
   - LOGNAME变量：
   - MAIL变量：
   - PATH变量：
   - HOSTNAME变量：
   - HISTSIZE变量：
   - umask：
   - 调用/etc/profile.d/*.sh文件
2. ~/.bash_profile的作用
   - 调用了~/.bashrc文件。
   - 在PATH变量后面加入了“:$HOME/bin”
     这个目录
3. ~/.bashrc的作用
   - 定义默认别名
   - 调用/etc/bashrc
4. /etc/bashrc的作用
   - PS1变量
   - umask
   - PATH变量
   - 调用/etc/profile.d/*.sh文件

```shell
~/.bash_logout	#注销时生效的环境变量配置文件
~/bash_history	#~/bash_history

```

**Shell登录信息** 

| 转义符 | 作 用                            |
| :----: | -------------------------------- |
|   \d   | 显示当前系统日期                 |
|   \s   | 显示操作系统名称                 |
|   \l   | 显示登录的终端号，这个比较常用。 |
|   \m   | 显示硬件体系结构，如i386、i686等 |
|   \n   | 显示主机名                       |
|   \o   | 显示域名                         |
|   \r   | 显示内核版本                     |
|   \t   | 显示当前系统时间                 |
|   \u   | 显示当前登录用户的序列号         |

1. 本地终端欢迎信息： /etc/issue

2. 远程终端欢迎信息： /etc/issue.net

   - 转义符在/etc/issue.net文件中不能使用

   - 是否显示此欢迎信息，由ssh的配置文件/etc/ssh/sshd_config决定，加入“Banner/etc/issue.net”行才能显示（记得重启SSH服务）

   - ```shell
     service sshd restart
     ```
   
3. 登陆后欢迎信息：/etc/motd

   - 不管是本地登录，还是远程登录，都可以显
     示此欢迎信息

### 10. Shell编程

---

#### 10.1 基础正则表达式

- **正则表达式**用来在文件中匹配符合条件的字符串，正则是**包含匹配**。grep、awk、sed等命令可以支持正则表达式。
- **通配符**用来匹配符合条件的文件名，通配符是**完全匹配**。ls、find、cp这些命令不支持正则表达式，所以只能使用shell自己的通配符来进行匹配了。`(*,?,[])`

基础正则表达式

|  元字符   | 作用                                                         |
| :-------: | ------------------------------------------------------------ |
|    `*`    | 前一个字符匹配0次或任意多次。                                |
|    `.`    | 匹配除了换行符外任意一个字符。                               |
|    `^`    | 匹配行首。例如：^hello会匹配以hello开头的行。                |
|    `$`    | 匹配行尾。例如：hello&会匹配以hello结尾的行。                |
|   `[]`    | 匹配中括号中指定的任意一个字符，只匹配一个字符。例如：`[aoeiu]` 匹配任意一个元音字母，[0-9] 匹配任意一位数字， `[a-z][0-9]`匹配小写字和一位数字构成的两位字符。 |
|   `[^]`   | 匹配除中括号的字符以外的任意一个字符。例如：`[^0-9]` 匹配任意一位非数字字符，`[^a-z]` 表示任意一位非小写字母。 |
|    `\`    | 转义符。用于取消讲特殊符号的含义取消。                       |
|  `\{n\}`  | 表示其前面的字符恰好出现n次。例如：`[0-9]\{4\} `匹配4位数字，`[1][3-8][0-9]\{9\} `匹配手机号码。 |
| `\{n,\}`  | 表示其前面的字符出现不小于n次。例如：` [0-9]\{2,\} `表示两位及以上的数字。 |
| `\{n,m\}` | 表示其前面的字符至少出现n次，最多出现m次。例如：`[a-z]\{6,8\} `匹配6到8位的小写字母。 |

```shell
grep "a*" test_rule.txt	#匹配所有内容，包括空白行
grep "aa*" test_rule.txt #匹配至少包含有一个a的行

grep "s.*d" test_rule.txt	#匹配在s和d字母之间有任意字符
grep ".*" test_rule.txt	#匹配所有内容

grep -n "^$" test_rule.txt	#会匹配空白行
grep "s[ao]id" test_rule.txt	#匹配s和i字母中，要不是a、要不是o

grep "^[^a-zA-Z]" test_rule.txt	#匹配不用字母开头的行

grep "sa\{1,3\}i" test_rule.txt	#匹配在字母s和字母i之间有最少一个a，最多三个a
```

扩展字符表达式

省略

#### 10.2 字符截取命令

cut字段截取命令 

```shell
cut [选项] 文件名	#截取列
-f 列号： 提取第几列		#此时分隔符是制表符
-d 分隔符： 按照指定分隔符分割列

cut -f 2,3 student.txt
cut -d ":" -f 1,3 /etc/passwd	

df -h | cut -d " " -f 1,3	#cut命令的局限
#空格为分隔符，需要使用awk命令
```

```shell
printf ’输出类型输出格式’ 输出内容
%ns： 输出字符串。n是数字指代输出几个字符
%ni： 输出整数。n是数字指代输出几个数字
%m.nf： 输出浮点数。m和n是数字，指代输出的整数位数和小数位数。如%8.2f代表共输出8位数，其中2位是小数，6位是整数。
```

输出格式

| 字符 | 代表含义                      |
| ---- | ----------------------------- |
| \a   | 输出警告声音                  |
| \b   | 输出退格键，也就是Backspace键 |
| \f   | 清除屏幕                      |
| \n   | 换行                          |
| \r   | 回车，也就是Enter键           |
| \t   | 水平输出退格键，也就是Tab键   |
| \v   | 垂直输出退格键，也就是Tab键   |



```shell
printf %s 1 2 3 4 5 6
printf '%s %s %s\n' 1 2 3 4 5 6
printf '%s\t %s\t %s\t\n' 1 2 3 4 5 6
```

awk命令的输出中支持print和printf命令

- print：print会在每个输出之后自动加入一个换行符（Linux默认没有print命令）
- printf：printf是标准格式输出命令，并不会自动加入换行符，如果需要换行，需要手工加入换行符

 

```shell
$ awk ‘条件1{动作1} 条件2{动作2}…’ 文件名
#条件（Pattern）：
#一般使用关系表达式作为条件
#x > 10 判断变量 x是否大于10
#x>=10 大于等于
#x<=10 小于等于
#动作（Action）：
#格式化输出
#流程控制语句

$ awk '{printf $2 "\t" $6 "\n"}' student.txt 	#输入出第二列和第六列
$ df -h | awk '{print $1 "\t" $3}'

# 先输出 This is a transcript，在执行后面的内容。
$ awk 'BEGIN{printf "This is a transcript \n" } {printf $2 "\t" $6 "\n"}' student.txt 
$ awk 'END{printf "The End \n" } {printf $2 "\t" $6 "\n"}' student.txt

#手工定义分隔符一定要加BEGIN，否则第一行来不及处理便输出
$ cat /etc/passwd | grep "/bin/bash" | awk 'BEGIN {FS=":"} {printf $1 "\t" $3 "\n"}' 

$ cat student.txt | grep -v Name | awk '$6 >= 87 {printf $2 "\n" }'
```

```shell
#sed 是一种几乎包括在所有 UNIX 平台（包括 Linux）的轻量级流编辑器。sed主要是用来将数据进行选取、替换、删除、新增的命令。

sed [选项] ‘[动作]’ 文件名
选项：
-n： 一般sed命令会把所有数据都输出到屏幕 ，如果加入此选择，则只会把经过sed命令处理的行输出到屏幕。
-e： 允许对输入数据应用多条sed命令编辑
-i： 用sed的修改结果直接修改读取数据的文件，而不是由屏幕输出
```

动作

| 字符串  | 作用                                                         |
| ------- | ------------------------------------------------------------ |
| `a \：` | 追加，在当前行后添加一行或多行。添加多行时，除最后 一行外，每行末尾需要用“\”代表数据未完结。 |
| `c \：` | 行替换，用c后面的字符串替换原数据行，替换多行时，除最后一行外，每行末尾需用“\”代表数据未完结。 |
| `i \：` | 插入，在当期行前插入一行或多行。插入多行时，除最后 一行外，每行末尾需要用“\”代表数据未完结。 |
| `d：`   | 删除，删除指定的行。                                         |
| `p：`   | 打印，输出指定的行。                                         |
| `s：`   | 字串替换，用一个字符串替换另外一个字符串。格式为“行范围s/旧字串/新字串/g”（和vim中的替换格式类似）。 |

```shell
$ df | sed '3p'		#输出第三行的同时将所有数据也输出了一遍
$ df | sed -n '3p'

#不修改文件本身,只是改变数据的输出
$ sed '2,4d' student.txt	#删除第二行到第四行的数据
$ sed '2a hello' student.txt	#在第二行后追加hello
$ sed '2i hello world' student.txt	#在第二行前插入两行数据
$ sed '2c No such person' student.txt	#数据替换，将第二行替换为No such person
$ sed '3s/74/99/g' student.txt	#在第三行中，把74换成99

$ sed -i '3s/74/99/g' student.txt	#-i,sed操作的数据直接写入文件
$ sed -e 's/Liming//g ; s/Gao//g' student.txt	#同时把“Liming”和“Gao”替换为空,s不加行号代表整篇文档，
```



#### 10.3 字符处理命令

```shell
sort [选项] 文件名	#排序命令
选项：
-f： 忽略大小写
-n： 以数值型进行排序，默认使用字符串型排序
-r： 反向排序
-t： 指定分隔符，默认是分隔符是制表符
-k n[,m]： 按照指定的字段范围排序。从第n字段开始，m字段结束（默认到行尾）
```

```shell
sort /etc/passwd	#排序用户信息文件
sort -r /etc/passwd	#反向排序
$ sort -t ":" -k 3,3 /etc/passwd	#指定分隔符是“：”，用第三字段开头，第三字段结尾排
序，就是只用第三字段排序
$ sort -n -t ":" -k 3,3 /etc/passwd
```

```shell
 wc [选项] 文件名	#统计命令
选项：
-l： 只统计行数
-w： 只统计单词数
-m： 只统计字符数
```

#### 10.4 条件判断

按照文件类型进行判断

| 测试选项 | 作 用                                                        |
| -------- | ------------------------------------------------------------ |
| -b 文件  | 判断该文件是否存在，并且是否为块设备文件（是块设备文件为真） |
| -c文件   | 判断该文件是否存在，并且是否为字符设备文件（是字符设备文件为真） |
| -d 文件  | 判断该文件是否存在，并且是否为目录文件（是目录为真）         |
| -e 文件  | 判断该文件是否存在（存在为真）                               |
| -f 文件  | 判断该文件是否存在，并且是否为普通文件（是普通文件为真）     |
| -L 文件  | 判断该文件是否存在，并且是否为符号链接文件（是符号链接文件为真） |
| -p 文件  | 判断该文件是否存在，并且是否为管道文件（是管道文件为真）     |
| -s 文件  | 判断该文件是否存在，并且是否为非空（非空为真）               |
| -S 文件  | 判断该文件是否存在，并且是否为套接字文件（是套接字文件为真） |

```shell
$ test -e /root/install.log	#通过 echo$? 查看上一条命令的执行结果
$ [ -e /root/install.log ]	#注意空格

$ [ -d /root ] && echo "yes" || echo "no"	#第一个判断命令如果正确执行，则打印“yes”，否则打印“no”
```

按照文件权限进行判断

| 测试选项 | 作 用                                                        |
| -------- | ------------------------------------------------------------ |
| -r 文件  | 判断该文件是否存在，并且是否该文件拥有读权限（有读权限为真） |
| -w 文件  | 判断该文件是否存在，并且是否该文件拥有写权限（有写权限为真） |
| -x 文件  | 判断该文件是否存在，并且是否该文件拥有执行权限（有执行权限为真） |
| -u 文件  | 判断该文件是否存在，并且是否该文件拥有SUID权限（有SUID权限为真） |
| -g 文件  | 判断该文件是否存在，并且是否该文件拥有SGID权限（有SGID权限为真） |
| -k 文件  | 判断该文件是否存在，并且是否该文件拥有SBit权限（有SBit权限为真） |

```shell
$ [ -w student.txt ] && echo "yes" || echo "no"	#判断文件是拥有写权限的,不区分身份
```

两个文件之间进行比较

| 测试选项        | 作 用                                                        |
| --------------- | ------------------------------------------------------------ |
| 文件1 -nt 文件2 | 判断文件1的修改时间是否比文件2的新（如果新则为真）           |
| 文件1 -ot 文件2 | 判断文件1的修改时间是否比文件2的旧（如果旧则为真）           |
| 文件1 -ef 文件2 | 判断文件1是否和文件2的Inode号一致，可以理解为两个文件是否为同一个文件。这个判断用于判断硬链接是很好的方法 |

```shell
ln /root/student.txt /tmp/stu.txt	#创建个硬链接吧
#用test测试下，果然很有用
[ /root/student.txt -ef /tmp/stu.txt ] && echo "yes" || echo "no" yes
```

两个整数之间比较

| 测试选项        | 作 用                                      |
| --------------- | ------------------------------------------ |
| 整数1 -eq 整数2 | 判断整数1是否和整数2相等（相等为真）       |
| 整数1 -ne 整数2 | 判断整数1是否和整数2不相等（不相等位置）   |
| 整数1 -gt 整数2 | 判断整数1是否大于整数2（大于为真）         |
| 整数1 -lt 整数2 | 判断整数1是否小于整数2（小于位置）         |
| 整数1 -ge 整数2 | 判断整数1是否大于等于整数2（大于等于为真） |
| 整数1 -le 整数2 | 判断整数1是否小于等于整数2（小于等于为真） |

```shell
[ 23 -ge 22 ] && echo "yes" || echo "no"	#判断23是否大于等于22，当然是了
[ 23 -le 22 ] && echo "yes" || echo "no"	#判断23是否小于等于22，当然不是了
```

字符串的判断

| 测试选项       | 作 用                                          |
| -------------- | ---------------------------------------------- |
| -z 字符串      | 判断字符串是否为空（为空返回真）               |
| -n 字符串      | 判断字符串是否为非空（非空返回真）             |
| 字串1 ==字串2  | 判断字符串1是否和字符串2相等（相等返回真）     |
| 字串1 != 字串2 | 判断字符串1是否和字符串2不相等（不相等返回真） |

```shell
name=sc		#给name变量赋值
[ -z "$name" ] && echo "yes" || echo "no"
#判断name变量是否为空，因为不为空，所以返回no

aa=11
bb=22	#给变量aa和变量bb赋值
#判断两个变量的值是否相等，明显不相等，所以返回no,注意空格
[ "$aa" == "bb" ] && echo "yes" || echo "no"
```

多重条件判断

| 测试选项       | 作 用                                                 |
| -------------- | ----------------------------------------------------- |
| 判断1 -a 判断2 | 逻辑与，判断1和判断2都成立，最终的结果才为真          |
| 判断1 -o 判断2 | 逻辑或，判断1和判断2有一个成立，最终的结果就为<br/>真 |
| ！判断         | 逻辑非，使原始的判断式取反                            |

```shell
$ aa=11
$ [ -n "$aa" -a "$aa" -gt 23 ] && echo "yes" || echo "no"

#判断变量aa是否有值，同时判断变量aa的是否大于23
#因为变量aa的值不大于23，所以虽然第一个判断值为真，返回的结果也是假
$ aa=24
$ [ -n "$aa" -a "$aa" -gt 23 ] && echo "yes" || echo "no"
```

#### 10.5 流程控制

```shell
if [ 条件判断式 ];then
	程序
fi
或者
if [ 条件判断式 ]
	then
		程序
fi

if [ 条件判断式 ]
	then
		条件成立时，执行的程序
	else
		条件不成立时，执行的另一个程序
fi

if [ 条件判断式1 ]
	then
		当条件判断式1成立时，执行程序1
elif [ 条件判断式2 ]
	then
		当条件判断式2成立时，执行程序2
···省略更多条件…
else
	当所有条件都不成立时，最后执行此程序
fi
```

- if语句使用fi结尾，和一般语言使用大括号结尾不同
- [ 条件判断式 ]就是使用test命令判断，所以中括号和条件判断式之间必须有空格
- then后面跟符合条件之后执行的程序，可以放在[]之后，用“；”分割。也可以换行写入，就不需要“；”了

```shell
#!/bin/bash
#统计根分区使用率
# Author: shenchao （E-mail: shenchao@lampbrother.net）
rate=$(df -h | grep "/dev/sda3" | awk '{print $5}' | cut -d "%" -f1)
#把根分区使用率作为变量值赋予变量rate

if [ $rate -ge 80 ]
 then
  echo "Warning! /dev/sda3 is full!!"
 fi
```



```shell
case $变量名 in
	"值1"）
		如果变量的值等于值1，则执行程序1
		;;
	"值2"）
		如果变量的值等于值2，则执行程序2
		;;
	…省略其他分支…
	*）
	如果变量的值都不是以上的值，则执行此程序
		;;
esac
```

```shell
for 变量 in 值1 值2 值3		#可以用变量来替代
	do
		程序
	done
	
for ((初始值；循环控制条件；变量变化))
	do
		程序
	done

```

```shell
#!/bin/bash
#从1加到100
# Author：abcd

s=0
for ((i=1;i<=100;i=i+1))
	do
		s=$(($s+$i))
	done
echo "The sum of 1+2+3+...+100 is:$s"
```



```shell
while [ 条件判断式 ]
do
程序
done
```

```shell
until [ 条件判断式 ]
do
程序
done
```

```shell
#!/bin/bash
#从1加到100
# Author: shenchao （E-mail: shenchao@lampbrother.net）
i=1
s=0
while [ $i -le 100 ]
#如果变量i的值小于等于100，则执行循环
	do
 		s=$(( $s+$i ))
		i=$(( $i+1 ))
	done
echo "The sum is: $s"
```

### 11. Linux服务管理

#### 11.1 RPM包默认安装的服务

```shell
$ chkconfig --list	#查看服务自启动状态，可以看到所有RPM包安装的服务，并不一定在当前运行
ps aux	#查看系统中所有运行进程
netstat	-tlun
```

RPM安装服务和源码包安装服务的区别就是安装位置的不同

- 源码包安装在指定位置，一般是/usr/local/
- RPM包安装在默认位置中



- /etc/init.d/：启动脚本位置
- /etc/sysconfig/：初始化环境配置文件位置
- /etc/：配置文件位置
- /etc/xinetd.conf：xinetd配置文件
- /etc/xinetd.d/：基于xinetd服务的启动脚本
- /var/lib/：服务产生的数据放在这里/var/log/：日志

独立的服务

```shell
#独立服务的启动，service命令是红帽的专有命令
/etc/init.d/独立服务名 start|stop|status|restart|
service 独立服务名 start|stop|restart||status
#列出系统所有RPM安装的服务的状态
service --status-all

#独立服务的自启动
chkconfig [--level 运行级别] [独立服务名] [on|off]
#或修改/etc/rc.d/rc.local文件，里面的命令会在登录之前执行，推荐使用。
#或使用ntsysv命令管理自启动，红帽专有命令
```

基于xinetd服务

```shell
#安装xinetd与telnet
yum -y install xinetd
yum -y install telnet-server	#不安全，试验后删掉

#xinetd服务的启动
vi /etc/xinetd.d/telnet
重启xinetd服务
service xinetd restart

#xinetd服务的自启动，xinetd的自启动和启动是相通的
chkconfig telnet on
ntsysv
```



#### 11.2 源码包安装的服务

查看服务安装位置，一般是/usr/local/下，不能用命令查看

使用绝对路径，调用启动脚本来启动。不同的源码包的启动脚本不同。可以查看源码包的安装说明，查看启动脚#本的方法。

/usr/local/apache2/bin/apachectl start|stop

```shell
#源码包服务的自启动
vi /etc/rc.d/rc.local
#加入
/usr/local/apache2/bin/apachectl start

#让源码包服务被服务管理命令识别
ln -s /usr/local/apache2/bin/apachectl /etc/init.d/apache

#让源码包的apache服务能被chkconfig与ntsysv命令管理自启动

vi /etc/init.d/apache
# chkconfig: 35 86 76
#指定httpd脚本可以被chkconfig命令管理。格式是：
chkconfig： 运行级别 启动顺序 关闭顺序
# description: source package apache
#说明，内容随意

chkconfig --add apache
#把源码包apache加入chkconfig命令
```

### 12. Linux系统管理

#### 12.1 进程管理

进程管理作用

- 判断服务器健康状态
- 查看系统中所有进程
- 杀死进程

```shell
#查看系统中所有进程
$ ps aux	#查看系统中所有进程，使用BSD操作系统格式，UNIX
$ ps -le	#查看系统中所有进程，使用Linux标准命令格式
```

-  USER：该进程是由哪个用户产生的；
-  PID：进程的ID号；
-  %CPU：该进程占用CPU资源的百分比，占用越高，进程越耗费资源；
-  %MEM：该进程占用物理内存的百分比，占用越高，进程越耗费资源；
-  VSZ：该进程占用虚拟内存的大小，单位KB；
- RSS：该进程占用实际物理内存的大小，单位KB；
-  **TTY**：该进程是在哪个终端中运行的。其中**tty1-tty7**代表本地控制台终端，t**ty1-tty6**是本地的**字符界面终端**，**tty7**是**图形终端**。**pts/0-255代表虚拟终端**。？表示由内核直接产生。
-  STAT：进程状态。常见的状态有：R：运行、S：睡眠、T：停止状态、s：包含子进程、+：位于后台
-  START：该进程的启动时间
- TIME：该进程占用CPU的运算时间，注意不是系统时间
- COMMAND：产生此进程的命令名

```shell
top [选项]	
选项：
-d 秒数： 指定top命令每隔几秒更新。默认是3秒，省略好像也一样

#在top命令的交互模式当中可以执行的命令：
？或h： 显示交互模式的帮助
P： 以CPU使用率排序，默认就是此项
M： 以内存的使用率排序
N： 以PID排序
q： 退出top
```

第一行信息为任务队列信息

| 内容                           | 说明                                                         |
| ------------------------------ | ------------------------------------------------------------ |
| 12:26:46                       | 系统当前时间                                                 |
| up 1 day, 13:32                | 系统的运行时间，本机已经运行1天13小时32分钟                  |
| 2 users                        | 当前登录了两个用户                                           |
| load average: 0.00, 0.00, 0.00 | 系统在之前1分钟，5分钟，15分钟的平均负载。一般认为小于1时，负载较小。如果大于1，系统已经超出负荷。如果是八核需要超过8 |

第二行为进程信息

| 内容            | 说明                                      |
| --------------- | ----------------------------------------- |
| Tasks: 95 total | 系统中的进程总数                          |
| 1 running       | 正在运行的进程数                          |
| 94 sleeping     | 睡眠的进程                                |
| 0 stopped       | 正在停止的进程                            |
| 0 zombie        | 僵尸进程。如果不是0，需要手工检查僵尸进程 |

第三行为CPU信息

| 内容           | 说明                                                         |
| -------------- | ------------------------------------------------------------ |
| Cpu(s): 0.1%us | 用户模式占用的CPU百分比                                      |
| 0.1%sy         | 系统模式占用的CPU百分比                                      |
| 0.0%ni         | 改变过优先级的用户进程占用的CPU百分比改变过优先级的用户进程占用的CPU百分比 |
| 99.7%id        | 空闲CPU的CPU百分比                                           |
| 0.1%wa         | 等待输入/输出的进程的占用CPU百分比                           |
| 0.0%hi         | 硬中断请求服务占用的CPU百分比                                |
| 0.1%si         | 软中断请求服务占用的CPU百分比                                |
| 0.0%st         | st（Steal time）虚拟时间百分比。就是当有虚拟机时，虚拟CPU等待实际CPU的时间百分比。 |

第四行为物理内存信息

| 内容               | 说明                                                         |
| ------------------ | ------------------------------------------------------------ |
| Mem: 625344k total | 物理内存的总量，单位KB                                       |
| 571504k used       | 已经使用的物理内存数量                                       |
| 53840k free        | 空闲的物理内存数量，我们使用的是虚拟机，总共只分配了628MB内存，所以>只有53MB的空闲内存了 |
| 65800k buffers     | 作为缓冲的内存数量                                           |

第五行为交换分区（swap）信息!

| 内容                | 说明                         |
| ------------------- | ---------------------------- |
| Swap: 524280k total | 交换分区（虚拟内存）的总大小 |
| 0k used             | 已经使用的交互分区的大小     |
| 524280k free        | 空闲交换分区的大小           |
| 409280k cached      | 作为缓存的交互分区的大小     |



```shell
pstree [选项]
选项：
-p： 显示进程的PID
-u： 显示进程的所属用户
```

```shell
$ kill –l	#查看可用的进程信号
```

常用进程信号

| 代号 | 信号名称 | 说明                                                         |
| ---- | -------- | ------------------------------------------------------------ |
| 1    | SIGHUP   | 该信号让进程立即关闭，然后重新读取配置文件之后**重启**。     |
| 2    | SIGINT   | 程序终止信号，用于终止前台进程。相当于输出ctrl+c快捷键。     |
| 8    | SIGFPE   | 在发生致命的算术运算错误时发出. 不仅包括浮点运算错误,还包括溢出及除数为0等其它所有的算术的错误。 |
| 9    | SIGKILL  | 用来立即结束程序的运行. 本信号不能被阻塞、处理和忽略。一般用于**强制终止进程**。 |
| 14   | SIGALRM  | 时钟定时信号, 计算的是实际的时间或时钟时间. alarm函数使用该信号。 |
| 15   | SIGTERM  | **正常结束进程**的信号，kill命令的默认信号。有时如果进程已经发生问题，这个信号是无法正常终止进程的，我们才会尝试SIGKILL信号，也就是信号9。 |
| 18   | SIGCONT  | 该信号可以让暂停的进程恢复执行，本信号不能被阻断。           |
| 19   | SIGSTOP  | 该信号可以暂停前台进程，相当于输入ctrl+z快捷键。本信号不能被阻断。 |

```shell
$ kill -1 22354	#重启进程，后跟的是PID号
$ kill -9 22368	#强制杀死进程
```

```shell
killall [选项][信号] 进程名	#按照进程名杀死进程，整个进程
选项：
-i： 交互式，询问是否要杀死某个进程
-I： 忽略进程名的大小写
```

```shell
pkill [选项] [信号] 进程名
#按照进程名终止进程
选项：
-t 终端号： 按照终端号踢出用户
```

```shell
$w	#使用w命令查询本机已经登录的用户
$ pkill -t -9 pts/1	#强制杀死从pts/1虚拟终端登录的进程
```

#### 12.2 工作管理

```shell
#把进程放入后台
tar -zcf etc.tar.gz /etc &

top #在top命令的执行过程中，按下crtl+Z快捷键，这种方法在后台是暂停的
```



#### 12.3 系统资源查看

```shell
vmstat [刷新延时 刷新次数]	#vmstat命令监控系统资源
$ vmstat 1 3
```

```shell
dmesg	#dmesg开机时内核检测信息
```

```shell
free [-b|-k|-m|-g]
选项：
-b： 以字节为单位显示
-k： 以KB为单位显示，默认就是以KB为单位显示
-m： 以MB为单位显示
-g： 以GB为单位显示
```

缓存（cache）是用来加速数据从硬盘中“读取”的，而缓冲（buffer）是用来加速数据“写入”硬盘的。

```shell
cat /proc/cpuinfo	#查看CPU信息
```

```shell
$ uptime	#显示系统的启动时间和平均负载，也就是top命令的第一行。w命令也可以看到这个数据。
```

```shell
uname [选项]		#查看系统与内核相关信息
选项：
-a： 查看系统所有相关信息；
-r： 查看内核版本；
-s： 查看内核名称。
```

```shell
file /bin/ls	#判断当前系统的位数
```

```shell
lsb_release -a	#查询当前Linux系统的发行版本
```

```shell
lsof [选项]	#列出进程打开或使用的文件信息
选项：
-c 字符串： 只列出以字符串开头的进程打开的文件
-u 用户名： 只列出某个用户的进程打开的文件
-p pid： 列出某个PID进程打开的文件
```



#### 12.4 系统定时任务

```shell
#crond服务管理与访问控制
$ service crond restart
$ chkconfig crond on
```

```shell
crontab [选项]	#用户的crontab设置
选项：
-e： 编辑crontab定时任务
-l： 查询crontab任务
-r： 删除当前用户所有的crontab任务

 crontab -e
#进入crontab编辑界面。会打开vim编辑你的工作。
```

| 项目      | 含义                 | 范围                    |
| --------- | -------------------- | ----------------------- |
| 第一个“*” | 一小时当中的第几分钟 | 0-59                    |
| 第二个“*” | 一天当中的第几小时   | 0-23                    |
| 第三个“*” | 一个月当中的第几天   | 1-31                    |
| 第四个“*” | 一年当中的第几月     | 1-12                    |
| 第五个“*” | 一周当中的星期几     | 0-7（0和7都代表星期日） |

| 特殊符号 | 含义                                                         |
| -------- | ------------------------------------------------------------ |
| *        | 代表任何时间。比如第一个“*”就代表一小时中每分钟都执行一次的意思。 |
| ，       | 代表不连续的时间。比如“0 8,12,16 * * * 命令”，就代表在每天的8点0分，12点0分，16点0分都执行一次命令 |
| -        | 代表连续的时间范围。比如“0 5 * * 1-6命令”，代表在周一到周六的凌晨5点0分执行命令 |
| */n      | 代表每隔多久执行一次。比如“*/10 * * * * 命令”，代表每隔10分钟就执行一遍命令 |

| 时间              | 含义                                                         |
| ----------------- | ------------------------------------------------------------ |
| 45 22 * * * 命令  | 在22点45分执行命令                                           |
| 0 17 * * 1 命令   | 每周1 的17点0分执行命令                                      |
| 0 5 1,15 * * 命令 | 每月1号和15号的凌晨5点0分执行命令                            |
| 40 4 * * 1-5 命令 | 每周一到周五的凌晨4点40分执行命令                            |
| */10 4 * * * 命令 | 每天的凌晨4点，每隔10分钟执行一次命令                        |
| 0 0 1,15 * 1 命令 | 每月1号和15号，每周1的0点0分都会执行命令。注意：星期几和几号最好不要同时出现，因为他们定义的都是天。非常容易让管理员混乱。 |

### 13 日志管理

#### 13.1日志管理简介

#### 13.2 rsyslogd日志服务

#### 13.3 日志轮替



#### 问题

我滴set咋了？？

网络服务？？课程？？

w和who区别

